<!doctype html><html lang=en-us dir=ltr><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  循环神经网络（Recurrent Neural Networks）
  #

传统的机器学习模型（如线性回归、逻辑回归和多层感知机）主要针对固定长度的数据，比如表格数据，这些数据通常以行和列的形式组织，其中每一行是一个样本，每一列是一个特征。对于这些模型，数据的结构并不重要，只需确保每个样本的特征数量固定即可。
在处理图像数据时，由于图像包含固定长度的像素信息，我们可以引入卷积神经网络（CNN）来捕获数据的层次结构和空间不变性。然而，这类数据仍然是固定长度的，例如Fashion-MNIST数据集中每张图像是固定大小的 



  \(28 \times 28\)

 的像素网格。
许多学习任务需要处理序列数据（Sequential Data）。例如，图像字幕生成、语音合成和音乐生成需要模型输出序列化数据；而时间序列预测、视频分析等任务需要模型从序列化数据中学习。在自然语言处理、对话系统设计、机器人控制等领域，这些输入和输出的序列特性通常同时存在。
循环神经网络（RNN） 是一种深度学习模型，专门设计用来捕获序列数据的动态特性。通过引入循环连接（可看作网络中的循环边），RNN能够跨时间步共享参数并传递信息。在展开视图中（即将循环连接按时间步展开），RNN可以看作一种特殊的前馈神经网络，其参数在各时间步间共享。循环连接动态地跨时间步传播信息，而常规连接则在同一时间步内传播信息。
RNN的核心思想是：许多输入和目标无法轻易表示为固定长度的向量，但可以表示为固定长度向量的变长序列。例如，文档可以表示为单词序列，医疗记录可以表示为事件序列，视频可以表示为静态图像序列。


  处理序列（Working with Sequences）
  #

在传统模型中，输入通常是单一的特征向量（feature vector）。而在处理序列数据时，输入变为一个有序的特征向量列表，每个特征向量按照时间步（time step）进行索引。这样的序列数据在许多场景中广泛存在，例如长时间的传感器数据流、文本序列或病人住院记录。
对于序列数据，有两种主要形式：

单个超长序列（如气候科学中的传感器数据流），可以通过随机采样固定长度的子序列生成训练数据集。
独立的多个序列集合（如文档集合，每个文档由不同长度的单词序列表示；或住院记录，每次住院由不同长度的事件序列组成）。

在传统的独立样本假设下，我们认为每个输入样本是从相同分布中独立采样的。而在序列数据中，尽管整个序列可以被认为是独立的，但序列内部的时间步之间往往具有强相关性。例如，文档后续单词的出现通常依赖于前面的单词，病人第10天的用药往往取决于前9天的病情记录。这种依赖性正是序列模型存在的意义：如果序列中的元素互不相关，就没有必要将其建模为序列。序列模型的核心在于捕捉这些依赖性。
根据任务目标的不同，序列建模可以分为以下几种类型：

固定目标预测：给定一个序列输入，预测一个固定目标，例如基于电影评论进行情感分类。

输入： 一个文本序列，例如电影评论。 dim = [batch_size, seq_length]，其中 batch_size 是批次大小，seq_length 是每个文本序列的长度。
输出：对应的情感类别（通常是一个标量），例如“正面”或“负面”。dim = [batch_size, 1] 或 [batch_size]，这是一个标量值表示类别。


序列目标预测：给定固定输入，预测一个序列目标，例如图像描述生成。

输入： 一个图像输入，通常是一个张量表示的图像或图像的特征（例如从CNN提取的特征向量）。 [batch_size, feature_size]，其中 feature_size 是图像特征的维度。
输出： 一个文本序列（描述）。[batch_size, seq_length]，其中 seq_length 是生成的描述的词数。


序列到序列预测：同时处理序列输入和序列输出。例如：

对齐的序列到序列任务：输入和输出在时间步上逐一对应，如词性标注（part-of-speech tagging）。

输入： 一个输入文本序列，例如源语言句子（例如英文句子）。[batch_size, seq_length]，其中 seq_length 是源语言句子的长度。
输出：一个输出文本序列，目标语言的翻译（例如中文句子）。 [batch_size, seq_length]，其中 seq_length 是目标语言句子的长度。


非对齐的序列到序列任务：输入与输出没有严格的时间步对应关系，如机器翻译或视频字幕生成。

输入：一个视频帧序列（或者是视频帧的特征表示）。[batch_size, num_frames, feature_size]，其中 num_frames 是视频帧数，feature_size 是每个帧的特征维度。
输出： 一个文本描述序列，描述视频内容。[batch_size, seq_length]，这是生成的字幕。







  自回归模型（Autoregressive Models）
  #

假设一位交易员希望进行短期交易，根据对下一时间步指数价格涨跌的预测来决定买入或卖出。如果没有其他辅助特征（如新闻或财报数据），交易员只能依据截至当前的价格历史数据预测下一时刻的价格。这时需要估计的就是价格在下一时间步可能取值的概率分布 
  \(P(x_{t+1} | x_1, \dots, x_t)\)

。由于直接估计连续变量的整个概率分布较为困难，交易员通常更关注分布的一些关键统计量，例如期望值（expected value）和方差（variance）。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="http://localhost:1313/docs/deep-learning/recurrent-neural-networks/"><meta property="og:site_name" content="Followblindly"><meta property="og:title" content="Recurrent Neural Networks"><meta property="og:description" content="循环神经网络（Recurrent Neural Networks） # 传统的机器学习模型（如线性回归、逻辑回归和多层感知机）主要针对固定长度的数据，比如表格数据，这些数据通常以行和列的形式组织，其中每一行是一个样本，每一列是一个特征。对于这些模型，数据的结构并不重要，只需确保每个样本的特征数量固定即可。
在处理图像数据时，由于图像包含固定长度的像素信息，我们可以引入卷积神经网络（CNN）来捕获数据的层次结构和空间不变性。然而，这类数据仍然是固定长度的，例如Fashion-MNIST数据集中每张图像是固定大小的 \(28 \times 28\) 的像素网格。
许多学习任务需要处理序列数据（Sequential Data）。例如，图像字幕生成、语音合成和音乐生成需要模型输出序列化数据；而时间序列预测、视频分析等任务需要模型从序列化数据中学习。在自然语言处理、对话系统设计、机器人控制等领域，这些输入和输出的序列特性通常同时存在。
循环神经网络（RNN） 是一种深度学习模型，专门设计用来捕获序列数据的动态特性。通过引入循环连接（可看作网络中的循环边），RNN能够跨时间步共享参数并传递信息。在展开视图中（即将循环连接按时间步展开），RNN可以看作一种特殊的前馈神经网络，其参数在各时间步间共享。循环连接动态地跨时间步传播信息，而常规连接则在同一时间步内传播信息。
RNN的核心思想是：许多输入和目标无法轻易表示为固定长度的向量，但可以表示为固定长度向量的变长序列。例如，文档可以表示为单词序列，医疗记录可以表示为事件序列，视频可以表示为静态图像序列。
处理序列（Working with Sequences） # 在传统模型中，输入通常是单一的特征向量（feature vector）。而在处理序列数据时，输入变为一个有序的特征向量列表，每个特征向量按照时间步（time step）进行索引。这样的序列数据在许多场景中广泛存在，例如长时间的传感器数据流、文本序列或病人住院记录。
对于序列数据，有两种主要形式：
单个超长序列（如气候科学中的传感器数据流），可以通过随机采样固定长度的子序列生成训练数据集。 独立的多个序列集合（如文档集合，每个文档由不同长度的单词序列表示；或住院记录，每次住院由不同长度的事件序列组成）。 在传统的独立样本假设下，我们认为每个输入样本是从相同分布中独立采样的。而在序列数据中，尽管整个序列可以被认为是独立的，但序列内部的时间步之间往往具有强相关性。例如，文档后续单词的出现通常依赖于前面的单词，病人第10天的用药往往取决于前9天的病情记录。这种依赖性正是序列模型存在的意义：如果序列中的元素互不相关，就没有必要将其建模为序列。序列模型的核心在于捕捉这些依赖性。
根据任务目标的不同，序列建模可以分为以下几种类型：
固定目标预测：给定一个序列输入，预测一个固定目标，例如基于电影评论进行情感分类。 输入： 一个文本序列，例如电影评论。 dim = [batch_size, seq_length]，其中 batch_size 是批次大小，seq_length 是每个文本序列的长度。 输出：对应的情感类别（通常是一个标量），例如“正面”或“负面”。dim = [batch_size, 1] 或 [batch_size]，这是一个标量值表示类别。 序列目标预测：给定固定输入，预测一个序列目标，例如图像描述生成。 输入： 一个图像输入，通常是一个张量表示的图像或图像的特征（例如从CNN提取的特征向量）。 [batch_size, feature_size]，其中 feature_size 是图像特征的维度。 输出： 一个文本序列（描述）。[batch_size, seq_length]，其中 seq_length 是生成的描述的词数。 序列到序列预测：同时处理序列输入和序列输出。例如： 对齐的序列到序列任务：输入和输出在时间步上逐一对应，如词性标注（part-of-speech tagging）。 输入： 一个输入文本序列，例如源语言句子（例如英文句子）。[batch_size, seq_length]，其中 seq_length 是源语言句子的长度。 输出：一个输出文本序列，目标语言的翻译（例如中文句子）。 [batch_size, seq_length]，其中 seq_length 是目标语言句子的长度。 非对齐的序列到序列任务：输入与输出没有严格的时间步对应关系，如机器翻译或视频字幕生成。 输入：一个视频帧序列（或者是视频帧的特征表示）。[batch_size, num_frames, feature_size]，其中 num_frames 是视频帧数，feature_size 是每个帧的特征维度。 输出： 一个文本描述序列，描述视频内容。[batch_size, seq_length]，这是生成的字幕。 自回归模型（Autoregressive Models） # 假设一位交易员希望进行短期交易，根据对下一时间步指数价格涨跌的预测来决定买入或卖出。如果没有其他辅助特征（如新闻或财报数据），交易员只能依据截至当前的价格历史数据预测下一时刻的价格。这时需要估计的就是价格在下一时间步可能取值的概率分布 \(P(x_{t+1} | x_1, \dots, x_t)\) 。由于直接估计连续变量的整个概率分布较为困难，交易员通常更关注分布的一些关键统计量，例如期望值（expected value）和方差（variance）。"><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><title>Recurrent Neural Networks | Followblindly</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=http://localhost:1313/docs/deep-learning/recurrent-neural-networks/><link rel=stylesheet href=/book.min.bff4c6870ba26abd815329272c8df8231704f9ac54bee84c3ef1f649e394d14f.css integrity="sha256-v/TGhwuiar2BUyknLI34IxcE+axUvuhMPvH2SeOU0U8=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.c1d5d3b1459293346cbdd74835ddb9c3cd955d0b54070652d7a2a892624fadb7.js integrity="sha256-wdXTsUWSkzRsvddINd25w82VXQtUBwZS16KokmJPrbc=" crossorigin=anonymous></script><link rel=alternate type=application/rss+xml href=http://localhost:1313/docs/deep-learning/recurrent-neural-networks/index.xml title=Followblindly></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/As.png alt=Logo class=book-icon><span>Followblindly</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><span>Python Basics</span><ul><li><a href=/docs/python-basics/python-fundamentals/>Python Fundamentals</a><ul></ul></li><li><input type=checkbox id=section-b0810fa42fa69050cb4968ec00fbf282 class=toggle>
<label for=section-b0810fa42fa69050cb4968ec00fbf282 class="flex justify-between"><a href=/docs/python-basics/leetcode/>Leetcode Notes</a></label><ul><li><a href=/docs/python-basics/leetcode/practice-history/>Practice History</a><ul></ul></li></ul></li></ul></li><li class=book-section-flat><input type=checkbox id=section-7e28d5ac3e9843e0deb580be9504447e class=toggle>
<label for=section-7e28d5ac3e9843e0deb580be9504447e class="flex justify-between"><a role=button>Common Libraries</a></label><ul><li><a href=/docs/common-libraries/numpy/>NumPy</a><ul></ul></li><li><a href=/docs/common-libraries/pandas/>Pandas</a><ul></ul></li><li><a href=/docs/common-libraries/pytorch/>PyTorch</a><ul></ul></li></ul></li><li class=book-section-flat><span>Machine Learning</span><ul><li><a href=/docs/machine-learning/machine-learning-basics/>Machine Learning Basics</a><ul></ul></li><li><a href=/docs/machine-learning/data-preprocessing/>Data Preprocessing</a><ul></ul></li><li><input type=checkbox id=section-89d4dd5d95507b817cf74368af5982ba class=toggle>
<label for=section-89d4dd5d95507b817cf74368af5982ba class="flex justify-between"><a href=/docs/machine-learning/supervised-learning/>Supervised Learning</a></label><ul><li><a href=/docs/machine-learning/supervised-learning/linear-regression/>Linear Regression</a><ul></ul></li><li><a href=/docs/machine-learning/supervised-learning/logistic-regression/>Logistic Regression</a><ul></ul></li></ul></li><li><input type=checkbox id=section-452d9bf73a55e6b3d947afcc89364ff4 class=toggle>
<label for=section-452d9bf73a55e6b3d947afcc89364ff4 class="flex justify-between"><a href=/docs/machine-learning/unsupervised-learning/>Unsupervised Learning</a></label><ul></ul></li><li><a href=/docs/machine-learning/regularization/>Regularization</a><ul></ul></li><li><a href=/docs/machine-learning/optimization/>Optimization</a><ul></ul></li><li><a href=/docs/machine-learning/computational-performance/>Computational Performance</a><ul></ul></li></ul></li><li class=book-section-flat><span>Deep Learning</span><ul><li><a href=/docs/deep-learning/perceptrons-and-neural-network/>Perceptrons and Neural Network</a><ul></ul></li><li><input type=checkbox id=section-d0dd931d60033c220ecd4cd60b7c9170 class=toggle>
<label for=section-d0dd931d60033c220ecd4cd60b7c9170 class="flex justify-between"><a href=/docs/deep-learning/convolutional-neural-networks/>Convolutional Neural Networks</a></label><ul><li><a href=/docs/deep-learning/convolutional-neural-networks/modern-convolutional-neural-networks/>Modern Convolutional Neural Networks</a><ul></ul></li></ul></li><li><input type=checkbox id=section-a3019bfa8037cc33ed6405d1589b6219 class=toggle checked>
<label for=section-a3019bfa8037cc33ed6405d1589b6219 class="flex justify-between"><a href=/docs/deep-learning/recurrent-neural-networks/ class=active>Recurrent Neural Networks</a></label><ul><li><a href=/docs/deep-learning/recurrent-neural-networks/modern-recurrent-neural-networks/>Modern Recurrent Neural Networks</a><ul></ul></li></ul></li><li><input type=checkbox id=section-0a43584c16258b228ae9aa8d70efc320 class=toggle>
<label for=section-0a43584c16258b228ae9aa8d70efc320 class="flex justify-between"><a href=/docs/deep-learning/attention-and-transformers/>Attention and Transformers</a></label><ul><li><a href=/docs/deep-learning/attention-and-transformers/tokenization-and-word-embeddings/>Tokenization and Word Embeddings</a><ul></ul></li><li><a href=/docs/deep-learning/attention-and-transformers/transformer-architecture/>Transformer Architecture</a><ul></ul></li><li><a href=/docs/deep-learning/attention-and-transformers/large-scale-pretraining-with-transformers/>Large-Scale Pretraining with Transformers</a><ul></ul></li><li><a href=/docs/deep-learning/attention-and-transformers/modern-large-language-models/>Modern Large Language Models</a><ul></ul></li><li><a href=/docs/deep-learning/attention-and-transformers/post-training-large-language-models/>Post-training Large Language Models</a><ul></ul></li><li><a href=/docs/deep-learning/attention-and-transformers/multimodal-large-language-models/>Multimodal Large Language Models</a><ul></ul></li></ul></li><li><input type=checkbox id=section-92e8358c45c96009753cf4227e9daea8 class=toggle>
<label for=section-92e8358c45c96009753cf4227e9daea8 class="flex justify-between"><a href=/docs/deep-learning/llm-pipelines/>LLM Pipelines</a></label><ul><li><a href=/docs/deep-learning/llm-pipelines/llm-hardware-and-model-size/>LLM Hardware and Model Size</a><ul></ul></li><li><a href=/docs/deep-learning/llm-pipelines/llm-inference-and-deployment/>LLM Inference and Deployment</a><ul></ul></li></ul></li></ul></li><li class=book-section-flat><input type=checkbox id=section-8b0266d7d6ac3da61ec6acf4e97681ca class=toggle>
<label for=section-8b0266d7d6ac3da61ec6acf4e97681ca class="flex justify-between"><a role=button>Others</a></label><ul><li><a href=/docs/others/interview-preparation-guide/>Interview Preparation Guide</a><ul></ul></li></ul></li></ul><ul><li><a href=/posts/>Blog</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Recurrent Neural Networks</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><link rel=stylesheet href=/css/prism-one-dark.css><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#处理序列working-with-sequences><strong>处理序列（Working with Sequences）</strong></a><ul><li><a href=#自回归模型autoregressive-models><strong>自回归模型（Autoregressive Models）</strong></a></li><li><a href=#序列模型sequence-models><strong>序列模型（Sequence Models）</strong></a></li></ul></li><li><a href=#文本预处理converting-raw-text-into-sequence-data><strong>文本预处理（Converting Raw Text into Sequence Data）</strong></a></li><li><a href=#语言模型和数据集language-models><strong>语言模型和数据集（Language Models）</strong></a><ul><li></li><li><a href=#困惑度perplexity><strong>困惑度（Perplexity）</strong></a></li><li><a href=#读取长序列数据partitioning-sequences><strong>读取长序列数据（Partitioning Sequences）</strong></a></li></ul></li><li><a href=#循环神经网络rnn概述><strong>循环神经网络（RNN）概述</strong></a><ul><li><a href=#rnn的结构与计算><strong>RNN的结构与计算</strong></a></li><li><a href=#基于循环神经网络的字符级语言模型><strong>基于循环神经网络的字符级语言模型</strong></a></li><li><a href=#one-hot-encoding-独热编码><strong>One-Hot Encoding 独热编码</strong></a></li><li><a href=#梯度裁剪gradient-clipping><strong>梯度裁剪（Gradient Clipping）</strong></a></li><li><a href=#解码-decoding><strong>解码 (Decoding)</strong></a></li></ul></li><li><a href=#rnn中的反向传播算法><strong>RNN中的反向传播算法</strong></a><ul><li><a href=#反向传播的细节><strong>反向传播的细节</strong></a></li></ul></li><li><a href=#简单循环神经网络实现><strong>简单循环神经网络实现</strong></a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=循环神经网络recurrent-neural-networks><strong>循环神经网络（Recurrent Neural Networks）</strong>
<a class=anchor href=#%e5%be%aa%e7%8e%af%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9crecurrent-neural-networks>#</a></h1><p>传统的机器学习模型（如线性回归、逻辑回归和多层感知机）主要针对固定长度的数据，比如表格数据，这些数据通常以行和列的形式组织，其中每一行是一个样本，每一列是一个特征。对于这些模型，<strong>数据的结构并不重要</strong>，只需确保每个样本的<strong>特征数量固定</strong>即可。</p><p>在处理图像数据时，由于图像包含固定长度的像素信息，我们可以引入卷积神经网络（CNN）来捕获数据的层次结构和空间不变性。然而，<strong>这类数据仍然是固定长度的</strong>，例如Fashion-MNIST数据集中每张图像是固定大小的
<link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script><script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><span>\(28 \times 28\)
</span>的像素网格。</p><p>许多学习任务需要<strong>处理序列数据（Sequential Data）</strong>。例如，图像字幕生成、语音合成和音乐生成需要模型输出序列化数据；而时间序列预测、视频分析等任务需要模型从序列化数据中学习。在自然语言处理、对话系统设计、机器人控制等领域，这些输入和输出的序列特性通常同时存在。</p><p>循环神经网络（RNN） 是一种深度学习模型，专门设计用来捕获序列数据的动态特性。通过引入循环连接（可看作网络中的循环边），RNN能够跨时间步共享参数并传递信息。在展开视图中（即将循环连接按时间步展开），RNN可以看作一种特殊的前馈神经网络，其参数在各时间步间共享。循环连接动态地跨时间步传播信息，而常规连接则在同一时间步内传播信息。</p><p><strong>RNN的核心思想</strong>是：许多输入和目标<strong>无法轻易表示为固定长度的向量</strong>，但<strong>可以表示为固定长度向量的变长序列</strong>。例如，文档可以表示为单词序列，医疗记录可以表示为事件序列，视频可以表示为静态图像序列。</p><hr><h2 id=处理序列working-with-sequences><strong>处理序列（Working with Sequences）</strong>
<a class=anchor href=#%e5%a4%84%e7%90%86%e5%ba%8f%e5%88%97working-with-sequences>#</a></h2><p>在传统模型中，输入通常是<strong>单一的特征向量（feature vector）</strong>。而在处理序列数据时，输入变为一个<strong>有序的特征向量列表</strong>，每个特征向量按照时间步（time step）进行索引。这样的序列数据在许多场景中广泛存在，例如长时间的传感器数据流、文本序列或病人住院记录。</p><p>对于序列数据，有两种主要形式：</p><ol><li><strong>单个超长序列</strong>（如气候科学中的传感器数据流），可以通过随机<strong>采样固定长度的子序列生成训练数据集</strong>。</li><li><strong>独立的多个序列集合</strong>（如文档集合，每个文档由不同长度的单词序列表示；或住院记录，每次住院由不同长度的事件序列组成）。</li></ol><p>在传统的独立样本假设下，我们认为每个输入<strong>样本是从相同分布中独立采样的</strong>。而在序列数据中，尽管整个序列可以被认为是独立的，但<strong>序列内部的时间步之间往往具有强相关性</strong>。例如，文档后续单词的出现通常依赖于前面的单词，病人第10天的用药往往取决于前9天的病情记录。这种依赖性正是序列模型存在的意义：<strong>如果序列中的元素互不相关，就没有必要将其建模为序列</strong>。序列模型的核心在于捕捉这些依赖性。</p><p>根据任务目标的不同，序列建模可以分为以下几种类型：</p><ol><li><strong>固定目标预测</strong>：给定一个序列输入，预测一个固定目标，例如基于电影评论进行情感分类。<ul><li><strong>输入</strong>： 一个文本序列，例如电影评论。 <code>dim = [batch_size, seq_length]</code>，其中 <code>batch_size</code> 是批次大小，<code>seq_length</code> 是每个文本序列的长度。</li><li><strong>输出</strong>：对应的情感类别（通常是一个标量），例如“正面”或“负面”。<code>dim = [batch_size, 1]</code> 或 <code>[batch_size]</code>，这是一个标量值表示类别。</li></ul></li><li><strong>序列目标预测</strong>：给定固定输入，预测一个序列目标，例如图像描述生成。<ul><li><strong>输入</strong>： 一个图像输入，通常是一个张量表示的图像或图像的特征（例如从CNN提取的特征向量）。 <code>[batch_size, feature_size]</code>，其中 <code>feature_size</code> 是图像特征的维度。</li><li><strong>输出</strong>： 一个文本序列（描述）。<code>[batch_size, seq_length]</code>，其中 <code>seq_length</code> 是生成的描述的词数。</li></ul></li><li><strong>序列到序列预测</strong>：同时处理序列输入和序列输出。例如：<ul><li>对齐的序列到序列任务：输入和输出在时间步上逐一对应，如词性标注（part-of-speech tagging）。<ul><li><strong>输入</strong>： 一个输入文本序列，例如源语言句子（例如英文句子）。<code>[batch_size, seq_length]</code>，其中 <code>seq_length</code> 是源语言句子的长度。</li><li><strong>输出</strong>：一个输出文本序列，目标语言的翻译（例如中文句子）。 <code>[batch_size, seq_length]</code>，其中 <code>seq_length</code> 是目标语言句子的长度。</li></ul></li><li>非对齐的序列到序列任务：输入与输出没有严格的时间步对应关系，如机器翻译或视频字幕生成。<ul><li><strong>输入</strong>：一个视频帧序列（或者是视频帧的特征表示）。<code>[batch_size, num_frames, feature_size]</code>，其中 <code>num_frames</code> 是视频帧数，<code>feature_size</code> 是每个帧的特征维度。</li><li><strong>输出</strong>： 一个文本描述序列，描述视频内容。<code>[batch_size, seq_length]</code>，这是生成的字幕。</li></ul></li></ul></li></ol><hr><h3 id=自回归模型autoregressive-models><strong>自回归模型（Autoregressive Models）</strong>
<a class=anchor href=#%e8%87%aa%e5%9b%9e%e5%bd%92%e6%a8%a1%e5%9e%8bautoregressive-models>#</a></h3><p>假设一位交易员希望进行短期交易，根据对下一时间步指数价格涨跌的预测来决定买入或卖出。如果没有其他辅助特征（如新闻或财报数据），交易员只能依据截至当前的价格历史数据预测下一时刻的价格。这时需要估计的就是价格在下一时间步可能取值的概率分布 <span>\(P(x_{t+1} | x_1, \dots, x_t)\)
</span>。由于直接估计连续变量的整个概率分布较为困难，交易员通常更关注分布的一些关键统计量，例如期望值（expected value）和方差（variance）。</p><p>一种简单的估计条件期望的方法是应用线性回归模型（linear regression model），即<strong>根据信号的历史值预测其未来值</strong>。这类模型被称为<strong>自回归模型（autoregressive models）</strong>。自回归模型假设当前时间步的观测值 <span>\(x_t\)
</span>是之前时间步观测值 <span>\(x_{t-1}, x_{t-2}, \dots\)
</span>的线性组合加上一个随机噪声项 <span>\(\epsilon_t\)
</span>。表达式如下：
<span>\[
x_t = c + \phi_1 x_{t-1} + \phi_2 x_{t-2} + \dots + \phi_p x_{t-p} + \epsilon_t
\]</span></p><blockquote class="book-hint warning"><p>自回归模型特指那些<strong>仅依赖于序列本身的历史观测值进行预测</strong>的统计模型。如果模型涉及到外部因素、非线性关系或更复杂的结构（如RNN、LSTM等），则它们不再是严格意义上的自回归模型。</p></blockquote><p>然而，自回归模型面临一个主要问题：输入数量 <span>\(t\)
</span><strong>随着时间步数增长而变化</strong>，导致每个样本的<strong>特征数量不一致</strong>。这给训练过程带来了挑战，因为许多模型（例如线性回归或深度网络）都<strong>要求固定长度的输入向量</strong>。克服这一挑战的常用策略有：</p><ol><li><strong>窗口化（Windowing）</strong>：为了简化模型的输入维度，可以假设在预测短期未来时，仅需要观察最近的 <span>\(\tau\)
</span>个时间步数据，而无需回溯到整个历史。这种情况下，只需使用一个长度为 <span>\(\tau\)
</span>的<strong>滑动窗口 <span>\((x_{t-\tau+1}, \dots, x_t)\)
</span>作为输入</strong>。这种方式<strong>确保了输入特征的数量固定</strong>，适用于许多要求固定输入长度的模型。</li><li><strong>隐变量模型（Latent Autoregressive Models）</strong>：构建一种模型，该模型通过<strong>维护一个过去观测值的总结 <span>\(h_t\)
</span>来压缩历史信息</strong>。在每个时间步，该模型<strong>不仅预测 <span>\(x_{t+1}\)
</span>，还更新摘要 <span>\(h_{t+1} = g(h_t, x_t)\)
</span></strong>。由于 <span>\(h_t\)
</span>是未观测到的<strong>隐变量（latent variable）</strong>，这样的模型也被称为<strong>隐变量自回归模型</strong>。这种方法可以捕捉更复杂的历史依赖关系。</li></ol><div align=center><img src=/images/sequence-model.svg width=300px/></div><hr><h3 id=序列模型sequence-models><strong>序列模型（Sequence Models）</strong>
<a class=anchor href=#%e5%ba%8f%e5%88%97%e6%a8%a1%e5%9e%8bsequence-models>#</a></h3><p>在处理序列数据，尤其是语言时，我们常常希望估计整个序列的联合概率。这种任务通常被称为<strong>序列建模（sequence modeling）</strong>，在自然语言处理中，序列建模常被称为语言模型（language model）。语言模型不仅可以用来评估句子的可能性，还能生成新序列或优化生成的序列。在语言建模中，我们可以通过链式法则将序列的联合概率分解成条件概率的乘积，从而将问题转化为自回归预测（autoregressive prediction）。如果序列数据是离散信号（如单词），<strong>自回归模型通常是一个概率分类器，输出词汇表中下一个词的概率分布</strong>。
<span>\[
P(x_1, \ldots, x_T) = P(x_1) \prod_{t=2}^T P(x_t \mid x_{t-1}, \ldots, x_1)
\]</span></p><p>有时我们会希望在建模时 <strong>仅依赖于前几个时间步的历史数据</strong>，而不是整个序列的历史。此时，如果我们丢弃超过前几个时间步的历史而不损失预测能力，我们称该序列满足 <strong>马尔可夫条件（Markov condition）</strong>，即 <strong>未来仅依赖于最近的历史</strong>，而与更早的历史无关。当我们仅依赖于前一个时间步时，数据符合一阶马尔可夫模型；如果依赖于前两个时间步，则符合二阶马尔可夫模型。在实际应用中，我们通常会选择近似满足马尔可夫条件的模型，尽管真实的文本数据会随着更多历史信息的加入逐渐改善预测效果，但增益是有限的。因此，有时我们会选择使用高阶马尔可夫模型，以减少计算和统计上的困难。
<span>\[
P(x_1, \ldots, x_T) = P(x_1) \prod_{t=2}^T P(x_t \mid x_{t-1})
\]</span></p><p>在文本序列解码时，通常选择按照<strong>从左到右的顺序来分解条件概率</strong>。这种顺序更符合我们日常阅读习惯（如大多数语言是从左到右读的），而且我们也能更直观地预测下一个可能出现的词。通过这种方式，我们可以为任意长的序列分配概率，只需要将新的词的条件概率乘以前面已计算的概率。此外，<strong>预测相邻词的模型通常比预测其他位置的词更加精准</strong>，这也是选择从左到右解码的一个原因。对于许多数据类型来说，这种顺序的预测比其他顺序更易于建模。例如，在因果结构数据中，未来的事件不能影响过去的事件，这使得从当前时刻预测未来比反向预测更容易。</p><blockquote class="book-hint warning"><p>基于 n-阶马尔可夫条件（Markov condition），即只依赖于前 n 个数据点来做预测。当我们用这种方式进行 <strong>一步预测（one-step-ahead prediction）时，模型效果良好，因为它依赖于已知的历史数据</strong>。（e.g. 基于时间点604 预测时间点 605）</p><p>然而，当我们进行 <strong>多步预测（multi-step-ahead prediction）</strong> 时，问题变得复杂。（e.g. 基于时间点604 预测时间点 609）我们无法直接通过已知数据计算预测值，因此我们需要利用先前的预测值作为输入来进行后续预测（e.g. 因为我们没有时间点 605-608 的数据，所以需要根据 604 先预测 605，再依据 605 预测 606，以此类推）。<strong>这种逐步递推的方式会导致预测的误差在每一步都积累。这些误差会随着时间步的推进而累积，导致预测结果逐渐偏离真实值</strong>。就像天气预报一样，短期预测较为准确，但长期预测误差逐渐增大。</p></blockquote><hr><h2 id=文本预处理converting-raw-text-into-sequence-data><strong>文本预处理（Converting Raw Text into Sequence Data）</strong>
<a class=anchor href=#%e6%96%87%e6%9c%ac%e9%a2%84%e5%a4%84%e7%90%86converting-raw-text-into-sequence-data>#</a></h2><p>在处理文本数据时，我们通常需要将原始文本转换为适合模型使用的数值形式。这一过程包含以下几个步骤：</p><ol><li><strong>读取文本数据</strong>：将原始文本加载为字符串，并预处理以去掉标点和大小写。</li><li><strong>分词（Tokenization）</strong>：将文本分割为基本的语义单元（Token）。Token可以是单词、字符，或更小的词片（Word Piece）。例如，句子“Baby needs a new pair of shoes”可以被表示为包含7个单词的序列或30个字符的序列。选择哪种形式取决于具体应用。</li><li><strong>构建词汇表（Vocabulary）</strong>：将Token映射到唯一的数值索引。首先确定训练数据中所有唯一Token的集合，并为每个Token分配索引。构建好的词汇表可以将字符串转换为数值序列，同时保留原始信息，支持将数值序列还原为字符串。例如：<pre tabindex=0><code>文本: [&#39;the&#39;, &#39;time&#39;, &#39;machine&#39;, &#39;by&#39;, &#39;h&#39;, &#39;g&#39;, &#39;wells&#39;]
索引: [1, 19, 50, 40, 2183, 2184, 400]
文本: [&#39;twinkled&#39;, &#39;and&#39;, &#39;his&#39;, &#39;usually&#39;, &#39;pale&#39;, &#39;face&#39;]
索引: [2186, 3, 25, 1044, 362, 113]
</code></pre></li></ol><ul><li><strong>文本预处理代码示例：</strong></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 原始文本</span>
</span></span><span style=display:flex><span>text <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Baby needs a new pair of shoes. Baby likes shoes too!&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 转小写并去掉标点符号</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> re
</span></span><span style=display:flex><span>processed_text <span style=color:#f92672>=</span> re<span style=color:#f92672>.</span>sub(<span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;[^\w\s]&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>, text<span style=color:#f92672>.</span>lower())
</span></span><span style=display:flex><span>print(processed_text)
</span></span><span style=display:flex><span><span style=color:#75715e># 输出: &#34;baby needs a new pair of shoes baby likes shoes too&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 按单词分词</span>
</span></span><span style=display:flex><span>tokens <span style=color:#f92672>=</span> processed_text<span style=color:#f92672>.</span>split()
</span></span><span style=display:flex><span>print(tokens)
</span></span><span style=display:flex><span><span style=color:#75715e># 输出: [&#39;baby&#39;, &#39;needs&#39;, &#39;a&#39;, &#39;new&#39;, &#39;pair&#39;, &#39;of&#39;, </span>
</span></span><span style=display:flex><span><span style=color:#75715e>#       &#39;shoes&#39;, &#39;baby&#39;, &#39;likes&#39;, &#39;shoes&#39;, &#39;too&#39;]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 构建词汇表</span>
</span></span><span style=display:flex><span>vocab <span style=color:#f92672>=</span> {token: idx <span style=color:#66d9ef>for</span> idx, token <span style=color:#f92672>in</span> enumerate(sorted(set(tokens)))}
</span></span><span style=display:flex><span>print(vocab)
</span></span><span style=display:flex><span><span style=color:#75715e># 输出: {&#39;a&#39;: 0, &#39;baby&#39;: 1, &#39;likes&#39;: 2, &#39;needs&#39;: 3, </span>
</span></span><span style=display:flex><span><span style=color:#75715e>#       &#39;new&#39;: 4, &#39;of&#39;: 5, &#39;pair&#39;: 6, &#39;shoes&#39;: 7, &#39;too&#39;: 8}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 将单词序列转换为数值索引序列</span>
</span></span><span style=display:flex><span>numerical_sequence <span style=color:#f92672>=</span> [vocab[token] <span style=color:#66d9ef>for</span> token <span style=color:#f92672>in</span> tokens]
</span></span><span style=display:flex><span>print(numerical_sequence)
</span></span><span style=display:flex><span><span style=color:#75715e># 输出: [1, 3, 0, 4, 6, 5, 7, 1, 2, 7, 8]</span>
</span></span></code></pre></div><hr><h2 id=语言模型和数据集language-models><strong>语言模型和数据集（Language Models）</strong>
<a class=anchor href=#%e8%af%ad%e8%a8%80%e6%a8%a1%e5%9e%8b%e5%92%8c%e6%95%b0%e6%8d%ae%e9%9b%86language-models>#</a></h2><p>语言模型通过估计整个文本序列的联合概率 <span>\(P(x_1, x_2, \dots, x_T)\)
</span>来建模语言，其中 <span>\(T\)
</span>是文本序列的长度，<span>
\(x_t\)
</span>表示序列中的第 <span>\(t\)
</span>个 token。这种联合概率可以分解为条件概率的连乘形式：
<span>\[
P(x_1, x_2, \dots, x_T) = \prod_{t=1}^{T} P(x_t \mid x_1, x_2, \dots, x_{t-1})
\]</span></p><blockquote><p>比如:
<span>\[
\begin{split}\begin{aligned}&P(\textrm{deep}, \textrm{learning}, \textrm{is}, \textrm{fun}) \\
=&P(\textrm{deep}) P(\textrm{learning} \mid \textrm{deep}) P(\textrm{is} \mid \textrm{deep}, \textrm{learning}) P(\textrm{fun} \mid \textrm{deep}, \textrm{learning}, \textrm{is}).\end{aligned}\end{split}
\]</span></p></blockquote><p>理想的语言模型不仅可以生成自然语言文本，还可以通过上下文信息生成合理的对话内容。然而，设计这样一个能够真正理解文本含义的系统仍然非常困难。</p><blockquote class="book-hint warning"><p><strong>Note：</strong> <strong>语言模型解决的问题</strong>：语言模型和根据给定的序列预测下一个词。它们的<strong>核心任务是</strong>：通过对前面已经出现的词（或符号）进行建模，来预测下一个最可能出现的词，或者生成后续的词序列。</p></blockquote><hr><h4 id=概率规则与马尔可夫模型markov-models><strong>概率规则与马尔可夫模型（Markov Models）</strong>
<a class=anchor href=#%e6%a6%82%e7%8e%87%e8%a7%84%e5%88%99%e4%b8%8e%e9%a9%ac%e5%b0%94%e5%8f%af%e5%a4%ab%e6%a8%a1%e5%9e%8bmarkov-models>#</a></h4><p>在马尔可夫模型中，序列满足一阶马尔可夫性质，即当前状态只依赖于前一个状态。根据依赖长度，模型可分为单词（Unigram）、双词（Bigram）和三词（Trigram）模型。模型参数包括单词概率和条件概率。
<span>\[
\begin{split}\begin{aligned}
P(x_1, x_2, x_3, x_4) &=  P(x_1) P(x_2) P(x_3) P(x_4),\\
P(x_1, x_2, x_3, x_4) &=  P(x_1) P(x_2  \mid  x_1) P(x_3 \mid x_2) P(x_4 \mid x_3),\\
P(x_1, x_2, x_3, x_4) &=  P(x_1) P(x_2  \mid  x_1) P(x_3 \mid x_1, x_2) P(x_4 \mid x_2, x_3).
\end{aligned}\end{split}
\]</span></p><hr><h4 id=词频估计word-frequency><strong>词频估计（Word Frequency）</strong>
<a class=anchor href=#%e8%af%8d%e9%a2%91%e4%bc%b0%e8%ae%a1word-frequency>#</a></h4><p>假设训练数据集是一个大规模的文本语料库，例如维基百科条目或网络上发布的所有文本。<strong>单词的概率可以通过该单词在训练数据中的相对词频来计算</strong>。例如，可以通过统计“deep”作为句子开头出现的次数，来估计概率。另一种稍微不准确的方法是统计“deep”出现的总次数，并除以语料库中的总单词数。这种方法对于频繁出现的单词效果较好。进一步地，可以尝试估计二元组（如“deep learning”）的概率：
<span>\[
\hat{P}(\textrm{learning} \mid \textrm{deep}) = \frac{\text{Count}(\text{deep, learning})}{\text{Count}(\text{deep})}
\]
</span>其中，分子是二元组的出现次数，分母是单个单词的出现次数。然而，估计二元组的概率更加困难，因为“deep learning”这样的二元组在语料库中出现的频率通常较低。对于一些不常见的词组合，可能很难找到足够的出现次数来进行准确的估计。</p><p>对于三元组及以上的组合情况（如“deep learning models”），问题变得更严重。<strong>许多可能的三词组合在语料库中可能完全不存在</strong>。如果不给这些词组合分配一个非零的计数，就无法在语言模型中使用它们。当数据集较小或单词本身极为罕见时，甚至可能找不到这些组合的任何一个实例。</p><p>因此，基于词频的简单统计方法虽然可以处理常见单词和短语，但在应对长序列或罕见组合时存在明显局限性，需要其他方法进行改进。</p><hr><h4 id=拉普拉斯平滑laplace-smoothing><strong>拉普拉斯平滑（Laplace Smoothing）</strong>
<a class=anchor href=#%e6%8b%89%e6%99%ae%e6%8b%89%e6%96%af%e5%b9%b3%e6%bb%91laplace-smoothing>#</a></h4><p>为此，我们使用拉普拉斯平滑（Laplace Smoothing）来改善上述问题。具体方法是在所有计数中添加一个小常量。 用<span>
\(n\)
</span>表示训练集中的单词总数，用<span>
\(m\)
</span>表示唯一单词的数量。
<span>\[
\begin{split}\begin{aligned}
\hat{P}(x) & = \frac{n(x) + \epsilon_1/m}{n + \epsilon_1}, \\
\hat{P}(x' \mid x) & = \frac{n(x, x') + \epsilon_2 \hat{P}(x')}{n(x) + \epsilon_2}, \\
\hat{P}(x'' \mid x,x') & = \frac{n(x, x',x'') + \epsilon_3 \hat{P}(x'')}{n(x, x') + \epsilon_3}.
\end{aligned}\end{split}
\]
</span>其中 <span>\(\epsilon_1,\epsilon_2\)
</span>，和 <span>\(\epsilon_3\)
</span>是超参数。以 <span>\(\epsilon_1\)
</span>为例：当 <span>\(\epsilon_1=0\)
</span>时，不应用平滑；当 <span>\(\epsilon_1\)
</span>接近正无穷大时，<span>
\(\hat{P}(x)\)
</span>接近均匀概率分布 <span>\(1/m\)
</span>。</p><p>然而，这样的模型很容易变得无效，原因如下： 首先，我们需要存储所有的计数； 其次，这完全忽略了单词的意思。 例如，“猫”（cat）和“猫科动物”（feline）可能出现在相关的上下文中， 但是想根据上下文调整这类模型其实是相当困难的。 最后，长单词序列大部分是没出现过的， 因此一个模型如果只是简单地统计先前“看到”的单词序列频率， 那么模型面对这种问题肯定是表现不佳的。</p><hr><h3 id=困惑度perplexity><strong>困惑度（Perplexity）</strong>
<a class=anchor href=#%e5%9b%b0%e6%83%91%e5%ba%a6perplexity>#</a></h3><p>衡量语言模型质量的一种方法是评估其对文本的预测能力。一个好的语言模型能够<strong>以较高的准确性预测下一个词（token）</strong>。例如，对于短语“It is raining”，不同模型可能生成以下扩展：</p><ol><li>“It is raining outside”（合理且逻辑通顺）</li><li>“It is raining banana tree”（语法正确但意义不通）</li><li>“It is raining piouw;kcj pwepoiut”（完全无意义且不合规范）</li></ol><p>显然，第一个扩展质量最好，模型能够捕获合理的词序和上下文语义。第二个扩展较差，但至少模型学会了单词拼写和部分词语之间的关联性。而第三个扩展表明模型训练不足，无法正确拟合数据。</p><p>为了量化模型质量，可以通过计算序列的似然（likelihood）。然而，直接比较似然值并不直观，因为较短的序列通常有更高的似然值。因此，需要一种标准化的方法使得不同长度的文档结果具有可比性。在信息论中，我们用交叉熵（cross-entropy）衡量模型对序列的预测能力。具体地，对于给定序列 <span>\(x_1, x_2, \ldots, x_n\)
</span>，交叉熵损失的公式为：
<span>\[
\frac{1}{n} \sum_{t=1}^n -\log P(x_t \mid x_{t-1}, \ldots, x_1)
\]
</span>这里， <span>\(P(x_t \mid x_{t-1}, \ldots, x_1)\)
</span>是模型预测的概率，<span>
\(x_t\)
</span>是序列中实际的词。这种方法将不同长度文档的性能变得可比。</p><p>自然语言处理领域通常使用<strong>困惑度（Perplexity）</strong> 作为评价标准，它是交叉熵损失的指数形式：
<span>\[
\text{Perplexity} = \exp\left(-\frac{1}{n} \sum_{t=1}^n \log P(x_t \mid x_{t-1}, \ldots, x_1)\right)
\]</span></p><p>困惑度可以理解为我们在选择下一个词时<strong>平均可用的真实选项数的倒数</strong>，具体如下：</p><ol><li><strong>最佳情况</strong>：模型对目标词的概率预测为 1，此时困惑度为 1，表明模型预测完全准确。</li><li><strong>最差情况</strong>：模型对目标词的概率预测为 0，此时困惑度为正无穷。</li><li><strong>基线情况</strong>：模型对所有词分布均匀预测，此时困惑度等于词汇表大小 <span>\(V\)
</span>。这提供了一个非平凡的上界，任何有用的模型都应超越这一基线。</li></ol><p><strong>困惑度越低，模型质量越高</strong>，表明其对文本序列的预测能力越强。</p><hr><h3 id=读取长序列数据partitioning-sequences><strong>读取长序列数据（Partitioning Sequences）</strong>
<a class=anchor href=#%e8%af%bb%e5%8f%96%e9%95%bf%e5%ba%8f%e5%88%97%e6%95%b0%e6%8d%aepartitioning-sequences>#</a></h3><p>由于序列数据本质上是连续的，因此我们在处理数据时需要解决这个问题。为了高效处理数据，模型通常以<strong>固定长度的序列小批量（minibatch）为单位</strong>进行训练。一个关键问题是如何从数据集中随机读取输入序列和目标序列的小批量。</p><p>假设数据集是一个表示语料库中词索引的序列。我们将其划分为固定长度 <span>\(n\)
</span>的子序列（subsequence）。为了在每个训练周期（epoch）中覆盖几乎所有的词，同时保证随机性，我们在每轮训练开始时丢弃前 <span>\(r\)
</span>个词，其中 <span>\(r\)
</span>是从均匀分布随机采样的整数。接下来，将剩余的序列划分为 <span>\(n\)
</span>长度的子序列。每个子序列从时间步 <span>\(i\)
</span>的第 <span>\(n\)
</span>个词开始，可以记为：
<span>\[
x_i = \{x_i, x_{i+1}, \ldots, x_{i+n-1}\}
\]
</span>假设网络一次只处理具有<span>
\(n\)
</span>个时间步的子序列。 下图画出了 从原始文本序列获得子序列的所有不同的方式， 其中<span>
\(n=5\)
</span>，并且每个时间步的词元对应于一个字符。</p><div align=center><img src=/images/timemachine-5gram.svg width=300px/></div><p>对于语言建模，目标是基于当前观察到的标记预测下一个标记。因此，<strong>对于任何输入序列 <span>\(x_i\)
</span>，目标序列（标签）是原始序列右移一个时间步，记为 <span>\(y_i\)
</span>，其长度与 <span>\(x_i\)
</span>相同</strong>。</p><blockquote class="book-hint warning"><p><strong>Note：</strong> 在语言模型中，<strong>截断长度 n 并不意味着只根据前 n 个词预测下一个词</strong>，而是定义了一种固定长度的输入序列，从中学习预测下一个词的能力。模型不仅仅预测输入序列的最后一个标记（如 D 的目标是 E），而是同时<strong>预测输入序列中所有时间步的下一个标记</strong>。</p></blockquote><ul><li><strong>准备输入数据和标签</strong></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TextDataset</span>(Dataset):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, data, vocab_size, seq_length):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>data <span style=color:#f92672>=</span> data  <span style=color:#75715e># 数据是一个索引序列</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>vocab_size <span style=color:#f92672>=</span> vocab_size
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>seq_length <span style=color:#f92672>=</span> seq_length
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __len__(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> len(self<span style=color:#f92672>.</span>data) <span style=color:#f92672>-</span> self<span style=color:#f92672>.</span>seq_length
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __getitem__(self, idx):
</span></span><span style=display:flex><span>        <span style=color:#75715e># 获取一个长度为seq_length的输入序列和一个目标值</span>
</span></span><span style=display:flex><span>        x <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>data[idx:idx <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>seq_length]  <span style=color:#75715e># [seq_length]</span>
</span></span><span style=display:flex><span>        y <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>data[idx <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>:idx <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>seq_length <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]  <span style=color:#75715e># [seq_length]，目标是下一个时间步的序列</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Inputs: tensor([[2, 3, 4],</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#                 [6, 7, 8]])</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Targets: tensor([[3, 4, 5],</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#                 [7, 8, 9]])</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> torch<span style=color:#f92672>.</span>tensor(x), torch<span style=color:#f92672>.</span>tensor(y)
</span></span></code></pre></div><hr><h2 id=循环神经网络rnn概述><strong>循环神经网络（RNN）概述</strong>
<a class=anchor href=#%e5%be%aa%e7%8e%af%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9crnn%e6%a6%82%e8%bf%b0>#</a></h2><p>在用马尔可夫模型和n-gram模型用于语言建模时，这些模型中某一时刻的词（token）只依赖于前 <span>\(n\)
</span>个词。如果我们希望将更早时间步的词对当前词的影响考虑进来，就需要增加 <span>\(n\)
</span>的值。然而，随着 <span>\(n\)
</span>增加，模型参数的数量也会呈指数级增长，因为需要为词汇表中的每个词存储对应的参数。因此， 因此与其将 <span>\(P(x_t \mid x_{t-1}, \ldots, x_{t-n+1})\)
</span>模型化，不如使用<strong>隐变量模型（latent variable model）</strong>：
<span>\[
P(x_t \mid x_{t-1}, \ldots, x_1) \approx P(x_t \mid h_{t-1})
\]
</span>潜在变量模型的核心思想是通过<strong>引入一个隐藏状态（hidden state）</strong>，它保存了直到当前时间步的序列信息。具体来说，隐藏状态在任意时间步 <span>\(t\)
</span>可以通过<strong>当前输入 <span>\(x_t\)
</span></strong>和<strong>上一个隐藏状态 <span>\(h_{t-1}\)
</span></strong>来计算：
<span>\[
h_t = f(x_{t}, h_{t-1})
\]
</span>这里，<span>
\(f\)
</span>是一个强大的函数，通过它可以计算隐藏状态。在这个模型中，隐藏状态不仅存储了之前所有的观测数据，而且通过适当设计，可以避免直接增加模型参数的数量。尽管如此，计算和存储的成本仍然可能较高。<strong>循环神经网络（RNN） 就是通过隐藏状态来建模序列数据的神经网络。</strong></p><blockquote class="book-hint warning"><p><strong>Note：</strong> “隐藏层”（hidden layers）和“隐藏状态”（hidden states）是两个完全不同的概念。隐藏层指的是从输入到输出路径中不可见的层，而<strong>隐藏状态是当前步骤的输入，可以通过查看之前的时间步的数据来计算</strong>。</p></blockquote><hr><h3 id=rnn的结构与计算><strong>RNN的结构与计算</strong>
<a class=anchor href=#rnn%e7%9a%84%e7%bb%93%e6%9e%84%e4%b8%8e%e8%ae%a1%e7%ae%97>#</a></h3><p>在没有隐藏状态的神经网络中（例如多层感知机，MLP），输入通过隐藏层的激活函数进行处理，得到隐藏层的输出。对于每个小批量 <span>\(\mathbf{X} \in \mathbb{R}^{n \times d}\)
</span>（minibatch）的输入，通过加权求和（包括偏置项），然后应用激活函数来计算隐藏层的输出 <span>\(\mathbf{H} \in \mathbb{R}^{n \times h}\)
</span>。
<span>\[
\mathbf{H} = \phi(\mathbf{X} \mathbf{W}_{xh} + \mathbf{b}_h)
\]
</span>这些输出将作为下一层（通常是输出层）的输入。输出层的计算则通过类似于回归问题的方法得到。如果是分类问题，输出层会通过激活函数（如softmax）生成概率分布，来预测输出类别。通过自动微分和随机梯度下降（SGD），可以优化网络的参数。
<span>\[
\mathbf{O} = \mathbf{H} \mathbf{W}_{hq} + \mathbf{b}_q,
\]</span></p><p>然而，当神经网络引入了 <strong>隐藏状态（hidden states）</strong> 时，情况就有所不同。假设在时间步 <span>\(t\)
</span>时，我们有一个小批量的输入 <span>\(x_t\)
</span>。与MLP不同，RNN在每个时间步 <span>\(t\)
</span>都会保存前一个时间步的隐藏状态 <span>\(h_{t-1}\)
</span>，并使用一个新的权重矩阵 <span>\(W_{hh}\)
</span>来结合当前输入和前一个时间步的隐藏状态进行计算。具体地，当前时间步的隐藏状态 <span>\(h_t\)
</span>由<strong>当前输入 <span>\(x_t\)
</span>和前一时间步的隐藏状态 <span>\(h_{t-1}\)
</span>共同决定</strong>：
<span>\[
\mathbf{H}_t = \phi(\mathbf{X}_t \mathbf{W}_{xh} + \mathbf{H}_{t-1} \mathbf{W}_{hh} + \mathbf{b}_h)
\]</span></p><p><span>\(\mathbf{X}_t\)
</span>是当前时间步的输入向量，其维度为 <span>\((\text{batch size}, \text{num inputs})\)
</span>，其中 <span>\(\text{batch size}\)
</span>是批量大小，<span>
\(\text{num inputs}\)
</span>是每个输入样本的特征数；<span>
\(\mathbf{H}_{t-1}\)
</span>是上一时间步的隐藏状态，维度为 <span>\((\text{batch size}, \text{num hiddens})\)
</span>，<span>
\(\text{num hiddens}\)
</span>表示隐藏单元的数量。权重矩阵 <span>\(\mathbf{W}_{xh}\)
</span>的维度为 <span>\((\text{num inputs}, \text{num hiddens})\)
</span>，用于将输入特征映射到隐藏单元；<span>
\(\mathbf{W}_{hh}\)
</span>的维度为 <span>\((\text{num hiddens}, \text{num hiddens})\)
</span>，用于描述隐藏单元之间的递归关系；<span>
\(\mathbf{b}_h\)
</span>是偏置向量，维度为 <span>\((\text{num hiddens},)\)
</span>。隐藏状态 <span>\(\mathbf{H}_t\)
</span>的维度为 <span>\((\text{batch size}, \text{num hiddens})\)
</span>，是激活函数 <span>\(\phi\)
</span>作用后的结果，捕捉当前时间步的特征和动态信息。</p><blockquote class="book-hint warning"><p><strong>Note：</strong> RNN 的隐藏单元与普通神经网络（NN）的隐藏单元<strong>有本质的不同</strong>。在传统的前馈神经网络（如全连接层，CNN）中，<strong>隐藏单元主要负责提取固定的特征表示</strong>。每个隐藏单元通常捕捉输入数据中的某种模式（feature），如图像的边缘、纹理或数据的非线性关系。</p><p>RNN 的隐藏单元不再是独立学习某个静态的特征，而是通过递归公式动态更新，捕捉输入序列中的时间依赖性规律，主要用于<strong>总结从时间步 1 到 t 的所有历史信息</strong>。例如，在自然语言处理中，RNN 的隐藏状态可以表示句子中已经看到的词的语义和语法结构。</p><p><strong>RNN 的隐藏状态仅对当前时间有效</strong>。RNN 的设计目标是逐步传播信息。当前时间步的隐藏状态 h_t 是基于前 t 个输入计算的「总结」，只对当前任务有直接的意义。它<strong>并不显式保留每个时间步的特征，而是对这些特征进行压缩和提炼</strong>。随着时间步的增加，隐藏状态会逐渐遗忘较早的输入信息。</p></blockquote><p>其中 <span>\(f\)
</span>表示激活函数，<span>
\(W_{xh}\)
</span>是输入到隐藏层的权重，<span>
\(W_{hh}\)
</span>是前一时间步隐藏状态到当前时间步的权重，<span>
\(b_h\)
</span>是偏置项。通过这种方式，RNN的隐藏层不仅仅依赖于当前输入，还考虑了历史信息，因此具有”记忆”的功能，<strong>隐藏状态就是网络当前时刻的”记忆”</strong>。</p><blockquote class="book-hint warning"><p><strong>Note：</strong> <strong>「num_inputs」 x 表示输入特征的维度</strong>。每个时间步的输入向量长度。如果输入是一个独热编码（one-hot encoding）表示的词汇，num_inputs 就等于词汇表的大小（vocabulary size）。例如，一个词汇表有 10000 个单词，使用独热编码表示每个单词，那么 num_inputs = 10000。</p><p><strong>「num_hiddens」h 表示 RNN 隐藏层中隐藏状态的维度</strong>。隐藏层状态向量的长度，<strong>控制网络的记忆能力</strong>（越大代表记忆能力越强）。每个时间步 RNN 的隐藏状态维度是固定的。如果 num_hiddens = 128，说明每个时间步的隐藏状态是一个 128 维的向量。</p></blockquote><p>在RNN中，隐藏状态的计算是递归的，意味着它依赖于前一个时间步的状态。这种递归计算的特点使得RNN能够处理序列数据，并捕捉数据中的时序依赖关系。RNN的每一层都执行这一递归计算，被称为<strong>递归层（recurrent layer）</strong>。</p><blockquote class="book-hint warning"><p><strong>Note：</strong> 在标准的RNN模型中，隐藏单元（hidden unit）的权重是共享的，<strong>即相同的权重矩阵 W_xh（从输入到隐藏状态的权重）和 W_hh（从上一个时间步的隐藏状态到当前隐藏状态的权重）在每个时间步都会被复用</strong>。这意味着，RNN通过不断更新隐藏状态，并依赖同一组权重来捕捉序列中的时序信息。尽管RNN在每个时间步都会计算新的隐藏状态，但在基础模型中<strong>没有涉及多层结构的概念</strong>。模型的核心是通过递归地传递隐藏状态来逐步更新信息。因此，RNN的“深度”通常指的是层数，在基础RNN中，只需要学习这些基本的权重。</p></blockquote><p>与MLP类似，RNN的输出层的计算也类似，只是它的输入是当前时间步的隐藏状态 <span>\(h_t\)
</span>。RNN的目标是根据当前的隐藏状态，输出当前时间步的预测结果：
<span>\[
\mathbf{O}_t = \mathbf{H}_t \mathbf{W}_{hq} + \mathbf{b}_q
\]</span></p><blockquote class="book-hint warning"><p><strong>Note：</strong> <strong>W_hq 是语言模型的输出层权重矩阵</strong>，主要负责将 RNN 隐藏状态（hidden state）映射到词汇表的概率分布。它将隐藏状态 H_{t} 转换为一个向量，其中<strong>每个维度对应词汇表中的一个词的得分</strong>。得分经过 softmax 转换为概率分布，用于预测下一个词的概率。</p><p>W_{xh} 负责将当前输入 X_{t} 映射到隐藏状态空间。 W_{hh} 负责将前一时间步隐藏状态 H_{t-1} 更新到当前时间步隐藏状态 H_{t} 。</p></blockquote><div align=center><img src=/images/rnn.svg width=550px/></div><p>上图展示了循环神经网络在三个相邻时间步的计算逻辑。 在任意时间步<span>
\(t\)
</span>，隐状态的计算可以被视为：</p><ol><li><strong>拼接当前时间步 <span>\(t\)
</span>的输入 <span>\(X_t\)
</span>和前一时间步 <span>\(t-1\)
</span>的隐状态 <span>\(H_{t-1}\)
</span></strong>；</li><li>将拼接的结果送入带有激活函数 <span>\(\phi\)
</span>的全连接层。 全连接层的输出是当前时间步的隐状态<span>
\(H_{t}\)
</span>。</li></ol><ul><li><strong>RNN 代码实现</strong><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> torch
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> torch <span style=color:#f92672>import</span> nn
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RNNScratch</span>(nn<span style=color:#f92672>.</span>Module):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, num_inputs, num_hiddens, sigma<span style=color:#f92672>=</span><span style=color:#ae81ff>0.01</span>):
</span></span><span style=display:flex><span>        super()<span style=color:#f92672>.</span>__init__()
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>num_inputs <span style=color:#f92672>=</span> num_inputs
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>num_hiddens <span style=color:#f92672>=</span> num_hiddens
</span></span><span style=display:flex><span>        <span style=color:#75715e># 初始化权重参数</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>W_xh <span style=color:#f92672>=</span> nn<span style=color:#f92672>.</span>Parameter(
</span></span><span style=display:flex><span>            torch<span style=color:#f92672>.</span>randn(num_inputs, num_hiddens) <span style=color:#f92672>*</span> sigma)  <span style=color:#75715e># 输入到隐藏层权重</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>W_hh <span style=color:#f92672>=</span> nn<span style=color:#f92672>.</span>Parameter(
</span></span><span style=display:flex><span>            torch<span style=color:#f92672>.</span>randn(num_hiddens, num_hiddens) <span style=color:#f92672>*</span> sigma)  <span style=color:#75715e># 隐藏层到隐藏层权重</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>b_h <span style=color:#f92672>=</span> nn<span style=color:#f92672>.</span>Parameter(torch<span style=color:#f92672>.</span>zeros(num_hiddens))  <span style=color:#75715e># 隐藏层偏置</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>forward</span>(self, inputs, state<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> state <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e># 初始化隐藏状态为零</span>
</span></span><span style=display:flex><span>            state <span style=color:#f92672>=</span> torch<span style=color:#f92672>.</span>zeros((inputs<span style=color:#f92672>.</span>shape[<span style=color:#ae81ff>1</span>], self<span style=color:#f92672>.</span>num_hiddens))
</span></span><span style=display:flex><span>        outputs <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> X <span style=color:#f92672>in</span> inputs:  <span style=color:#75715e># X 的形状为 (batch_size, num_inputs)</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># 隐藏状态更新公式</span>
</span></span><span style=display:flex><span>            state <span style=color:#f92672>=</span> torch<span style=color:#f92672>.</span>tanh(torch<span style=color:#f92672>.</span>matmul(X, self<span style=color:#f92672>.</span>W_xh) <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                            torch<span style=color:#f92672>.</span>matmul(state, self<span style=color:#f92672>.</span>W_hh) <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>b_h)
</span></span><span style=display:flex><span>            outputs<span style=color:#f92672>.</span>append(state)  <span style=color:#75715e># 保存每个时间步的输出</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> outputs, state
</span></span></code></pre></div></li></ul><blockquote class="book-hint warning"><p><strong>Note：</strong> <strong>为什么以列表保存state</strong>？</p><p>在RNN的过程中，我们通常需要保存每个时间步的隐藏状态（state）。在序列输入-序列输出（Sequence-to-Sequence）任务中，比如机器翻译、时间序列预测、语音生成等，<strong>模型需要对每一个时间步生成对应的输出</strong>。在这些情况下，每个时间步的隐藏状态都需要被保存。</p></blockquote><hr><h3 id=基于循环神经网络的字符级语言模型><strong>基于循环神经网络的字符级语言模型</strong>
<a class=anchor href=#%e5%9f%ba%e4%ba%8e%e5%be%aa%e7%8e%af%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c%e7%9a%84%e5%ad%97%e7%ac%a6%e7%ba%a7%e8%af%ad%e8%a8%80%e6%a8%a1%e5%9e%8b>#</a></h3><p>假设我们将文本“machine”作为输入序列，并且为了简化训练过程，我们将文本划分为字符，而不是词汇。在训练过程中，对于每个时间步，我们对输出层的结果进行 softmax 操作，然后使用交叉熵损失函数计算模型输出和目标之间的误差。在 RNN 中，由于隐层的隐藏状态是递归计算的，因此第 3 个时间步的输出是由“m”、“a”和“c”三个字符决定的。由于训练数据中序列的下一个字符是“h”，因此第 3 个时间步的损失将依赖于基于特征序列“m”、“a”、“c”生成的下一个字符的概率分布，并与目标“h”进行比较。</p><div align=center><img src=/images/rnn-train.svg width=550px/></div><p>在实际应用中，每个字符通常表示为一个维度为 <span>\(d\)
</span>的向量，而我们使用批量大小 <span>\(B\)
</span>。因此，在时间步 <span>\(t\)
</span>时的输入将是一个 <span>\(B \times d\)
</span>的矩阵。</p><hr><h3 id=one-hot-encoding-独热编码><strong>One-Hot Encoding 独热编码</strong>
<a class=anchor href=#one-hot-encoding-%e7%8b%ac%e7%83%ad%e7%bc%96%e7%a0%81>#</a></h3><p>在处理类别型数据（如词汇中的单词或字符）时，常用 <strong>独热编码（One-Hot Encoding）</strong> 表示。独热<strong>向量的长度等于词汇表大小</strong>，<strong>只有一个位置的值为1，其余为0</strong>。例如，词汇表长度为5时，索引0和2的独热向量分别为：<span>
\([1, 0, 0, 0, 0] \quad \text{and} \quad [0, 0, 1, 0, 0]\)
</span>。</p><p>对于每个输入的时间步，独热编码生成的输入张量形状为 (<span>
\(\text{batch size}, \text{time steps}, \text{vocab size}\)
</span>)。模型通常会转置输入，以方便循环逐时间步更新隐状态。</p><ul><li><strong>RNN One-Hot Encoding运用代码实现</strong><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RNNLMScratch</span>(nn<span style=color:#f92672>.</span>Module):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;从零实现的基于 RNN 的语言模型&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, rnn, vocab_size, sigma<span style=color:#f92672>=</span><span style=color:#ae81ff>0.01</span>):
</span></span><span style=display:flex><span>        super()<span style=color:#f92672>.</span>__init__()
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>rnn <span style=color:#f92672>=</span> rnn  <span style=color:#75715e># RNN 模型</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>vocab_size <span style=color:#f92672>=</span> vocab_size
</span></span><span style=display:flex><span>        <span style=color:#75715e># 输出层参数</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>W_hq <span style=color:#f92672>=</span> nn<span style=color:#f92672>.</span>Parameter(torch<span style=color:#f92672>.</span>randn(rnn<span style=color:#f92672>.</span>num_hiddens, vocab_size) <span style=color:#f92672>*</span> sigma)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>b_q <span style=color:#f92672>=</span> nn<span style=color:#f92672>.</span>Parameter(torch<span style=color:#f92672>.</span>zeros(vocab_size))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>one_hot</span>(self, X):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;将输入转换为独热编码&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> F<span style=color:#f92672>.</span>one_hot(X<span style=color:#f92672>.</span>T, self<span style=color:#f92672>.</span>vocab_size)<span style=color:#f92672>.</span>type(torch<span style=color:#f92672>.</span>float32)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>output_layer</span>(self, rnn_outputs):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;应用输出层将隐藏状态映射到词表&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        outputs <span style=color:#f92672>=</span> [torch<span style=color:#f92672>.</span>matmul(H, self<span style=color:#f92672>.</span>W_hq) <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>b_q <span style=color:#66d9ef>for</span> H <span style=color:#f92672>in</span> rnn_outputs]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> torch<span style=color:#f92672>.</span>stack(outputs, dim<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)  <span style=color:#75715e># 形状: (batch_size, num_steps, vocab_size)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>forward</span>(self, X, state<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;前向传播&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        embs <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>one_hot(X)  <span style=color:#75715e># 独热编码: (num_steps, batch_size, vocab_size)</span>
</span></span><span style=display:flex><span>        rnn_outputs, state <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>rnn(embs, state)  <span style=color:#75715e># 经过 RNN</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>output_layer(rnn_outputs), state  <span style=color:#75715e># 返回输出和最终隐藏状态</span>
</span></span></code></pre></div></li></ul><hr><h3 id=梯度裁剪gradient-clipping><strong>梯度裁剪（Gradient Clipping）</strong>
<a class=anchor href=#%e6%a2%af%e5%ba%a6%e8%a3%81%e5%89%aagradient-clipping>#</a></h3><p>在RNN中，序列长度引入了新的深度概念：输入不仅在单个时间步内通过网络从输入传播到输出，还需要沿着时间步形成一个深度为 <span>\(T\)
</span>的层链。反向传播时，<strong>梯度需要通过这条时间链传递，从而形成长度为 <span>\(T\)
</span>的矩阵乘积链</strong>。由于权重矩阵的特性，梯度可能会出现数值不稳定的情况，导致<strong>梯度爆炸（exploding gradients）或消失（vanishing gradients）</strong>。</p><p>当梯度过大时，可能在一次梯度更新中对模型造成严重破坏，甚至导致训练发散或损失函数不稳定。最直接的方法是：<strong>减小学习率</strong>，但这会降低所有训练步骤的优化效率，即使大梯度事件是少数。<strong>梯度裁剪</strong> 是一种更常见的替代方法是将<strong>梯度投影到一个以半径 <span>\(\theta\)
</span>为界的球中，限制梯度范数不超过 <span>\(\theta\)
</span></strong>，公式为：
<span>\[
\mathbf{g} \leftarrow \min\left(1, \frac{\theta}{\|\mathbf{g}\|}\right) \mathbf{g}
\]</span></p><p>这样做确保了梯度大小受到控制，并且更新后的梯度方向与原始梯度一致。这种方法还可以限制单个小批量数据对模型参数的影响，提高模型的鲁棒性。</p><ul><li><strong>梯度裁剪（Gradient Clipping）代码实现</strong>：<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>clip_gradients</span>(model, grad_clip_val):
</span></span><span style=display:flex><span>    <span style=color:#75715e># 筛选需要梯度更新的参数</span>
</span></span><span style=display:flex><span>    params <span style=color:#f92672>=</span> [p <span style=color:#66d9ef>for</span> p <span style=color:#f92672>in</span> model<span style=color:#f92672>.</span>parameters() <span style=color:#66d9ef>if</span> p<span style=color:#f92672>.</span>requires_grad]
</span></span><span style=display:flex><span>    <span style=color:#75715e># 计算梯度的 L2 范数</span>
</span></span><span style=display:flex><span>    total_norm <span style=color:#f92672>=</span> torch<span style=color:#f92672>.</span>sqrt(sum(torch<span style=color:#f92672>.</span>sum(p<span style=color:#f92672>.</span>grad <span style=color:#f92672>**</span> <span style=color:#ae81ff>2</span>) <span style=color:#66d9ef>for</span> p <span style=color:#f92672>in</span> params))
</span></span><span style=display:flex><span>    <span style=color:#75715e># 如果梯度范数超过阈值，则按比例缩小</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> total_norm <span style=color:#f92672>&gt;</span> grad_clip_val:
</span></span><span style=display:flex><span>        scaling_factor <span style=color:#f92672>=</span> grad_clip_val <span style=color:#f92672>/</span> total_norm
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> param <span style=color:#f92672>in</span> params:
</span></span><span style=display:flex><span>            param<span style=color:#f92672>.</span>grad[:] <span style=color:#f92672>*=</span> scaling_factor
</span></span></code></pre></div>梯度裁剪通常在<strong>训练过程的反向传播（backward pass）之后和参数更新（optimizer.step()）之前</strong>执行。这是因为梯度裁剪的目的是直接对反向传播计算得到的梯度进行操作，在它们被优化器用来更新模型参数之前对其进行规范化或限制。<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> epoch <span style=color:#f92672>in</span> range(num_epochs):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> batch_inputs, batch_targets <span style=color:#f92672>in</span> dataloader:
</span></span><span style=display:flex><span>        <span style=color:#75715e># 前向传播</span>
</span></span><span style=display:flex><span>        logits, hidden_state <span style=color:#f92672>=</span> model(batch_inputs, hidden_state)
</span></span><span style=display:flex><span>        loss <span style=color:#f92672>=</span> criterion(logits<span style=color:#f92672>.</span>view(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, vocab_size), batch_targets<span style=color:#f92672>.</span>view(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 反向传播</span>
</span></span><span style=display:flex><span>        optimizer<span style=color:#f92672>.</span>zero_grad()
</span></span><span style=display:flex><span>        loss<span style=color:#f92672>.</span>backward()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 自定义梯度裁剪</span>
</span></span><span style=display:flex><span>        clip_gradients(model, grad_clip_val)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 参数更新</span>
</span></span><span style=display:flex><span>        optimizer<span style=color:#f92672>.</span>step()
</span></span></code></pre></div></li></ul><hr><h3 id=解码-decoding><strong>解码 (Decoding)</strong>
<a class=anchor href=#%e8%a7%a3%e7%a0%81-decoding>#</a></h3><p>在训练好语言模型后，模型不仅可以预测下一个 token，还可以通过将前一个预测的 token 作为输入，连续地预测后续的 token。这种解码过程既可以从一个空白文档开始生成文本，也可以基于用户提供的前缀 (prefix) 来生成。比如，在搜索引擎的自动补全功能或邮件撰写助手中，可以将用户已经输入的内容作为前缀，生成可能的续写。解码过程的步骤可以总结为：</p><ol><li><strong>Warm-up阶段</strong>：<ul><li>解码开始时，将前缀输入到模型中，不输出任何结果。</li><li>目的是通过传递隐藏状态 <span>\(\text{hidden state}\)
</span>，初始化模型内部状态以适应上下文。</li></ul></li><li><strong>续写生成</strong>：<ul><li>在输入完前缀后，模型开始生成后续字符。</li><li>每次生成一个字符，将其作为下一个时间步的输入，依次循环生成目标长度的文本。</li></ul></li><li><strong>输入和输出映射</strong>：<ul><li>使用独热编码（one-hot embedding）处理输入。</li><li>通过输出层预测字符分布，并选择概率最大的字符作为结果。</li></ul></li></ol><ul><li><strong>RNN 预测部分代码实现</strong><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>predict</span>(model, prefix, num_preds, vocab, device<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    基于前缀生成文本
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Parameters:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        model: nn.Module
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            用于生成文本的语言模型，通常包含 RNN 和输出层。
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        prefix: list[str]
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            文本生成的前缀，即用于初始化上下文信息的一段文本序列。例如 [&#34;I&#34;, &#34;love&#34;]。
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        num_preds: int
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            需要生成的后续单词数（预测的时间步数）。
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        vocab: object
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            词汇表对象，通常具有以下属性：
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                - vocab[token]: 将 token 转换为其对应的索引。
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                - vocab.idx_to_token: 索引到 token 的映射，用于将生成的索引还原为文本。
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        str
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            拼接后的生成文本，包括前缀和预测的后续内容。
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    state <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>  <span style=color:#75715e># 初始化RNN的状态</span>
</span></span><span style=display:flex><span>    outputs <span style=color:#f92672>=</span> [vocab[prefix[<span style=color:#ae81ff>0</span>]]]  <span style=color:#75715e># 将前缀的第一个字符的索引加入输出序列</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(prefix) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):  <span style=color:#75715e># Warm-up阶段</span>
</span></span><span style=display:flex><span>        X <span style=color:#f92672>=</span> torch<span style=color:#f92672>.</span>tensor([[outputs[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]]], device<span style=color:#f92672>=</span>device)  <span style=color:#75715e># 当前输入</span>
</span></span><span style=display:flex><span>        embs <span style=color:#f92672>=</span> model<span style=color:#f92672>.</span>one_hot(X)  <span style=color:#75715e># 获取当前输入的独热编码</span>
</span></span><span style=display:flex><span>        rnn_outputs, state <span style=color:#f92672>=</span> model<span style=color:#f92672>.</span>rnn(embs, state)  <span style=color:#75715e># 经过RNN更新状态</span>
</span></span><span style=display:flex><span>        outputs<span style=color:#f92672>.</span>append(vocab[prefix[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]])  <span style=color:#75715e># 继续在输出序列中加入前缀的下一个字符</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 预测阶段，生成后续字符</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(num_preds):  <span style=color:#75715e># 预测num_preds步</span>
</span></span><span style=display:flex><span>        X <span style=color:#f92672>=</span> torch<span style=color:#f92672>.</span>tensor([[outputs[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]]], device<span style=color:#f92672>=</span>device)  <span style=color:#75715e># 当前输入</span>
</span></span><span style=display:flex><span>        embs <span style=color:#f92672>=</span> model<span style=color:#f92672>.</span>one_hot(X)  <span style=color:#75715e># 获取当前输入的独热编码</span>
</span></span><span style=display:flex><span>        rnn_outputs, state <span style=color:#f92672>=</span> model<span style=color:#f92672>.</span>rnn(embs, state)  <span style=color:#75715e># 经过RNN更新状态</span>
</span></span><span style=display:flex><span>        Y <span style=color:#f92672>=</span> model<span style=color:#f92672>.</span>output_layer(rnn_outputs)  <span style=color:#75715e># 通过输出层映射到词汇表</span>
</span></span><span style=display:flex><span>        next_token <span style=color:#f92672>=</span> int(Y<span style=color:#f92672>.</span>argmax(axis<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)<span style=color:#f92672>.</span>reshape(<span style=color:#ae81ff>1</span>))  <span style=color:#75715e># 选择最大概率的字符</span>
</span></span><span style=display:flex><span>        outputs<span style=color:#f92672>.</span>append(next_token)  <span style=color:#75715e># 将预测结果添加到输出序列</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 将索引转为对应的字符并拼接为生成的文本</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join([vocab<span style=color:#f92672>.</span>idx_to_token[i] <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> outputs])
</span></span></code></pre></div></li></ul><hr><h2 id=rnn中的反向传播算法><strong>RNN中的反向传播算法</strong>
<a class=anchor href=#rnn%e4%b8%ad%e7%9a%84%e5%8f%8d%e5%90%91%e4%bc%a0%e6%92%ad%e7%ae%97%e6%b3%95>#</a></h2><p>时间反向传播是将递归神经网络（RNN）展开为一个时间步长的计算图，并通过链式法则对参数进行梯度反向传播。它的主要挑战在于处理长序列时可能出现的数值不稳定问题，比如梯度爆炸和梯度消失。</p><p>在简化模型中，我们将时间步 <span>\(t\)
</span>的隐状态表示为 <span>\(h_t\)
</span>，输入表示为 <span>\(x_t\)
</span>，输出表示为 <span>\(o_t\)
</span>。 输入和隐状态可以拼接后与隐藏层中的一个权重变量相乘。 因此，我们分别使用 <span>\(w_h\)
</span>和 <span>\(w_o\)
</span>来表示隐藏层和输出层的权重。 每个时间步的隐状态和输出可以写为：</p><span>\[
\begin{split}\begin{aligned}h_t &= f(x_t, h_{t-1}, w_h),\\
o_t &= g(h_t, w_o),\end{aligned}\end{split}
\]</span><p>其中 <span>\(f\)
</span>和 <span>\(g\)
</span>分别是隐藏层和输出层的变换。 因此，我们有一个链 <span>\(\{\ldots, (x_{t-1}, h_{t-1}, o_{t-1}), (x_{t}, h_{t}, o_t), \ldots\}\)
</span>，它们通过循环计算彼此依赖。前向传播相当简单，一次一个时间步的遍历三元组 <span>\((x_t, h_t, o_t)\)
</span>，然后通过一个目标函数在所有个时间步 <span>\(T\)
</span>内 评估输出 <span>\(o_t\)
</span>和对应的标签 <span>\(y_t\)
</span>之间的差异：</p><span>\[
L(x_1, \ldots, x_T, y_1, \ldots, y_T, w_h, w_o) = \frac{1}{T}\sum_{t=1}^T l(y_t, o_t)
\]</span><p>对于反向传播，按照链式法则：</p><span>\[
\begin{split}\begin{aligned}\frac{\partial L}{\partial w_h} & = \frac{1}{T}\sum_{t=1}^T \frac{\partial l(y_t, o_t)}{\partial w_h} \\& = \frac{1}{T}\sum_{t=1}^T \frac{\partial l(y_t, o_t)}{\partial o_t} \frac{\partial g(h_t, w_o)}{\partial h_t} \frac{\partial h_t}{\partial w_h}.\end{aligned}\end{split}
\]</span><p>乘积的第一项和第二项很容易计算，而第三项 <span>\(\partial h_t/\partial w_h\)
</span>是使事情变得棘手的地方，因为我们需要循环地计算参数对的影响。使用链式法则得到：</p><span>\[
\begin{split}\begin{aligned}
\frac{\partial h_t}{\partial w_h} &= \frac{\partial f(x_{t},h_{t-1},w_h)}{\partial w_h} +\frac{\partial f(x_{t},h_{t-1},w_h)}{\partial h_{t-1}} \frac{\partial h_{t-1}}{\partial w_h} \\
& =\frac{\partial f(x_{t},h_{t-1},w_h)}{\partial w_h}+\sum_{i=1}^{t-1}\left(\prod_{j=i+1}^{t} \frac{\partial f(x_{j},h_{j-1},w_h)}{\partial h_{j-1}} \right) \frac{\partial f(x_{i},h_{i-1},w_h)}{\partial w_h}. \end{aligned}\end{split}
\]</span><p>虽然我们可以使用链式法则递归地计算 <span>\(\partial h_t/\partial w_h\)
</span>， 但当 <span>\(t\)
</span>很大时这个链就会变得很长。<strong>常用解决策略</strong>可以总结为：</p><ol><li><strong>全量计算：</strong> 对所有时间步长进行完整的梯度反向传播，然而，这样的计算非常缓慢，并且可能会发生梯度爆炸，因为初始条件的微小变化就可能会对结果产生巨大的影响。</li><li><strong>时间步截断（Truncated BPTT）：</strong> 截断时间步长，仅计算过去 <span>\(\tau\)
</span>步的梯度。这样做导致该模型主要侧重于短期影响，而不是长期影响。 这在现实中是可取的，因为它会将估计值偏向更简单和更稳定的模型。</li><li><strong>随机截断（Randomized Truncation）：</strong> 用一个随机变量替换 <span>\(\partial h_t/\partial w_h\)
</span>，该随机变量在预期中是正确的，但是会截断序列。虽然随机截断在理论上具有吸引力， 但很可能是由于多种因素在实践中并不比常规截断更好。</li></ol><hr><h3 id=反向传播的细节><strong>反向传播的细节</strong>
<a class=anchor href=#%e5%8f%8d%e5%90%91%e4%bc%a0%e6%92%ad%e7%9a%84%e7%bb%86%e8%8a%82>#</a></h3><p>在时间反向传播（BPTT）中，我们需要计算目标函数对模型参数的梯度。考虑一个没有偏置参数的循环神经网络， 其在隐藏层中的激活函数使用恒等映射（<span>
\(\phi(x)=x\)
</span>）。对于时间步 <span>\(t\)
</span>，设单个样本的输入及其对应的标签分别为 <span>\(\mathbf{x}_t \in \mathbb{R}^d\)
</span>和 <span>\(y_{t}\)
</span>。 计算隐状态 <span>\(\mathbf{h}_t \in \mathbb{R}^h\)
</span>和输出 <span>\(\mathbf{o}_t \in \mathbb{R}^q\)
</span>的方式为：</p><span>\[
\begin{split}\begin{aligned}\mathbf{h}_t &= \mathbf{W}_{hx} \mathbf{x}_t + \mathbf{W}_{hh} \mathbf{h}_{t-1},\\
\mathbf{o}_t &= \mathbf{W}_{qh} \mathbf{h}_{t},\end{aligned}\end{split}
\]</span><p>其中权重参数为 <span>\(\mathbf{W}_{hx} \in \mathbb{R}^{h \times d}\)
</span>、<span>
\(\mathbf{W}_{hh} \in \mathbb{R}^{h \times h}\)
</span>和 <span>\(\mathbf{W}_{qh} \in \mathbb{R}^{q \times h}\)
</span>。用 <span>\(l(\mathbf{o}_t, y_t)\)
</span>表示时间步处（即从序列开始起的超过 <span>\(T\)
</span>个时间步）的损失函数， 则我们的目标函数的总体损失是：</p><span>\[
L = \frac{1}{T} \sum_{t=1}^T l(\mathbf{o}_t, y_t).
\]</span><div align=center><img src=/images/01_biological_neuron.svg width=450px/></div><p>损失函数对输出 <span>\(\mathbf{o}_t\)
</span>的梯度计算如下：
<span>\[
\frac{\partial L}{\partial \mathbf{o}_t} = \frac{\partial l (\mathbf{o}_t, y_t)}{T \cdot \partial \mathbf{o}_t} \in \mathbb{R}^q.
\]</span></p><p>对于输出层参数 <span>\(\mathbf{W}_{qh}\)
</span>，使用链式法则得：</p><span>\[
\frac{\partial L}{\partial \mathbf{W}_{qh}}
= \sum_{t=1}^T \text{prod}\left(\frac{\partial L}{\partial \mathbf{o}_t}, \frac{\partial \mathbf{o}_t}{\partial \mathbf{W}_{qh}}\right)
= \sum_{t=1}^T \frac{\partial L}{\partial \mathbf{o}_t} \mathbf{h}_t^\top,
\]</span><p>对于最终时间步 <span>\(T\)
</span>，目标函数只通过 <span>\(\mathbf{o}_T\)
</span>依赖于隐藏状态 <span>\(\mathbf{h}_T\)
</span>，因此：
<span>\[
\frac{\partial L}{\partial \mathbf{h}_T} = \text{prod}\left(\frac{\partial L}{\partial \mathbf{o}_T}, \frac{\partial \mathbf{o}_T}{\partial \mathbf{h}_T} \right) = \mathbf{W}_{qh}^\top \frac{\partial L}{\partial \mathbf{o}_T}.
\]</span></p><p>对于中间时间步 <span>\(t\)
</span>，隐藏状态 <span>\(\mathbf{h}_t\)
</span>同时通过 <span>\(\mathbf{o}_t\)
</span>和 <span>\(\mathbf{h}_{t+1}\)
</span>影响目标函数。利用递归公式计算：</p><span>\[
\frac{\partial L}{\partial \mathbf{h}_t} = \text{prod}\left(\frac{\partial L}{\partial \mathbf{h}_{t+1}}, \frac{\partial \mathbf{h}_{t+1}}{\partial \mathbf{h}_t} \right) + \text{prod}\left(\frac{\partial L}{\partial \mathbf{o}_t}, \frac{\partial \mathbf{o}_t}{\partial \mathbf{h}_t} \right) = \mathbf{W}_{hh}^\top \frac{\partial L}{\partial \mathbf{h}_{t+1}} + \mathbf{W}_{qh}^\top \frac{\partial L}{\partial \mathbf{o}_t}.
\]</span><p>展开递归公式可得：</p><span>\[
\frac{\partial L}{\partial \mathbf{h}_t}= \sum_{i=t}^T {\left(\mathbf{W}_{hh}^\top\right)}^{T-i} \mathbf{W}_{qh}^\top \frac{\partial L}{\partial \mathbf{o}_{T+t-i}}.
\]</span><p><strong>在长序列中，由于 <span>\(\mathbf{W}_{hh}\)
</span>的特征值可能远小于或大于 1，导致梯度逐步消失或爆炸。</strong></p><p>最终隐藏层参数 <span>\(\mathbf{W}_{xh}\)
</span>和 <span>\(\mathbf{W}_{hh}\)
</span>的梯度计算如下：
<span>\[
\begin{split}\begin{aligned}
\frac{\partial L}{\partial \mathbf{W}_{hx}}
&= \sum_{t=1}^T \text{prod}\left(\frac{\partial L}{\partial \mathbf{h}_t}, \frac{\partial \mathbf{h}_t}{\partial \mathbf{W}_{hx}}\right)
= \sum_{t=1}^T \frac{\partial L}{\partial \mathbf{h}_t} \mathbf{x}_t^\top,\\
\frac{\partial L}{\partial \mathbf{W}_{hh}}
&= \sum_{t=1}^T \text{prod}\left(\frac{\partial L}{\partial \mathbf{h}_t}, \frac{\partial \mathbf{h}_t}{\partial \mathbf{W}_{hh}}\right)
= \sum_{t=1}^T \frac{\partial L}{\partial \mathbf{h}_t} \mathbf{h}_{t-1}^\top,
\end{aligned}\end{split}
\]</span></p><hr><h2 id=简单循环神经网络实现><strong>简单循环神经网络实现</strong>
<a class=anchor href=#%e7%ae%80%e5%8d%95%e5%be%aa%e7%8e%af%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c%e5%ae%9e%e7%8e%b0>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> torch
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> torch.nn <span style=color:#66d9ef>as</span> nn
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> torch.optim <span style=color:#66d9ef>as</span> optim
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># RNN模型定义</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RNN</span>(nn<span style=color:#f92672>.</span>Module):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, num_inputs, num_hiddens):
</span></span><span style=display:flex><span>        super()<span style=color:#f92672>.</span>__init__()
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>rnn <span style=color:#f92672>=</span> nn<span style=color:#f92672>.</span>RNN(num_inputs, num_hiddens, batch_first<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>forward</span>(self, inputs, hidden_state<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>rnn(inputs, hidden_state)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># RNN语言模型定义</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RNNLM</span>(nn<span style=color:#f92672>.</span>Module):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;基于RNN的语言模型&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, rnn, vocab_size, num_hiddens, lr<span style=color:#f92672>=</span><span style=color:#ae81ff>1e-2</span>):
</span></span><span style=display:flex><span>        super(RNNLM, self)<span style=color:#f92672>.</span>__init__()
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>rnn <span style=color:#f92672>=</span> rnn
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>vocab_size <span style=color:#f92672>=</span> vocab_size
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>num_hiddens <span style=color:#f92672>=</span> num_hiddens
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>linear <span style=color:#f92672>=</span> nn<span style=color:#f92672>.</span>Linear(num_hiddens, vocab_size)  <span style=color:#75715e># 输出层</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>softmax <span style=color:#f92672>=</span> nn<span style=color:#f92672>.</span>Softmax(dim<span style=color:#f92672>=-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>lr <span style=color:#f92672>=</span> lr
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>forward</span>(self, inputs, hidden_state<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>        <span style=color:#75715e># 前向传播，输入通过RNN，接着通过线性层</span>
</span></span><span style=display:flex><span>        rnn_output, hidden_state <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>rnn(inputs, hidden_state)
</span></span><span style=display:flex><span>        output <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>linear(rnn_output)  <span style=color:#75715e># 获取输出</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> output, hidden_state
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>output_layer</span>(self, hiddens):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>linear(hiddens)<span style=color:#f92672>.</span>swapaxes(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>init_params</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;初始化模型参数&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> name, param <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>named_parameters():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#39;weight&#39;</span> <span style=color:#f92672>in</span> name:
</span></span><span style=display:flex><span>                nn<span style=color:#f92672>.</span>init<span style=color:#f92672>.</span>normal_(param, mean<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, std<span style=color:#f92672>=</span><span style=color:#ae81ff>0.01</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                nn<span style=color:#f92672>.</span>init<span style=color:#f92672>.</span>zeros_(param)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>predict</span>(self, prefix, num_preds, vocab, device<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;基于前缀生成文本&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        state <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>        outputs <span style=color:#f92672>=</span> [vocab[prefix[<span style=color:#ae81ff>0</span>]]]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(prefix) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):  <span style=color:#75715e># Warm-up 阶段</span>
</span></span><span style=display:flex><span>            X <span style=color:#f92672>=</span> torch<span style=color:#f92672>.</span>tensor([[outputs[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]]], device<span style=color:#f92672>=</span>device)  <span style=color:#75715e># 当前输入</span>
</span></span><span style=display:flex><span>            embs <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>one_hot(X)  <span style=color:#75715e># 获取当前输入的独热编码</span>
</span></span><span style=display:flex><span>            rnn_outputs, state <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>rnn(embs, state)  <span style=color:#75715e># 经过RNN更新状态</span>
</span></span><span style=display:flex><span>            outputs<span style=color:#f92672>.</span>append(vocab[prefix[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]])  <span style=color:#75715e># 继续在输出序列中加入前缀的下一个字符</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># 预测阶段，生成后续字符</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(num_preds):  <span style=color:#75715e># 预测num_preds步</span>
</span></span><span style=display:flex><span>            X <span style=color:#f92672>=</span> torch<span style=color:#f92672>.</span>tensor([[outputs[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]]], device<span style=color:#f92672>=</span>device)  <span style=color:#75715e># 当前输入</span>
</span></span><span style=display:flex><span>            embs <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>one_hot(X)  <span style=color:#75715e># 获取当前输入的独热编码</span>
</span></span><span style=display:flex><span>            rnn_outputs, state <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>rnn(embs, state)  <span style=color:#75715e># 经过RNN更新状态</span>
</span></span><span style=display:flex><span>            Y <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>output_layer(rnn_outputs)  <span style=color:#75715e># 通过输出层映射到词汇表</span>
</span></span><span style=display:flex><span>            next_token <span style=color:#f92672>=</span> int(Y<span style=color:#f92672>.</span>argmax(axis<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)<span style=color:#f92672>.</span>reshape(<span style=color:#ae81ff>1</span>))  <span style=color:#75715e># 选择最大概率的字符</span>
</span></span><span style=display:flex><span>            outputs<span style=color:#f92672>.</span>append(next_token)  <span style=color:#75715e># 将预测结果添加到输出序列中</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># 将索引转为对应的字符并拼接为生成的文本</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join([vocab<span style=color:#f92672>.</span>idx_to_token[i] <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> outputs])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>one_hot</span>(self, X):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;将输入转换为独热编码&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> torch<span style=color:#f92672>.</span>nn<span style=color:#f92672>.</span>functional<span style=color:#f92672>.</span>one_hot(X<span style=color:#f92672>.</span>T, self<span style=color:#f92672>.</span>vocab_size)<span style=color:#f92672>.</span>float()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 实例化模型</span>
</span></span><span style=display:flex><span>rnn <span style=color:#f92672>=</span> RNN(num_inputs<span style=color:#f92672>=</span>len(vocab), num_hiddens<span style=color:#f92672>=</span><span style=color:#ae81ff>32</span>)
</span></span><span style=display:flex><span>model <span style=color:#f92672>=</span> RNNLM(rnn, vocab_size<span style=color:#f92672>=</span>len(vocab), num_hiddens<span style=color:#f92672>=</span><span style=color:#ae81ff>32</span>, lr<span style=color:#f92672>=</span><span style=color:#ae81ff>0.01</span>)
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#处理序列working-with-sequences><strong>处理序列（Working with Sequences）</strong></a><ul><li><a href=#自回归模型autoregressive-models><strong>自回归模型（Autoregressive Models）</strong></a></li><li><a href=#序列模型sequence-models><strong>序列模型（Sequence Models）</strong></a></li></ul></li><li><a href=#文本预处理converting-raw-text-into-sequence-data><strong>文本预处理（Converting Raw Text into Sequence Data）</strong></a></li><li><a href=#语言模型和数据集language-models><strong>语言模型和数据集（Language Models）</strong></a><ul><li></li><li><a href=#困惑度perplexity><strong>困惑度（Perplexity）</strong></a></li><li><a href=#读取长序列数据partitioning-sequences><strong>读取长序列数据（Partitioning Sequences）</strong></a></li></ul></li><li><a href=#循环神经网络rnn概述><strong>循环神经网络（RNN）概述</strong></a><ul><li><a href=#rnn的结构与计算><strong>RNN的结构与计算</strong></a></li><li><a href=#基于循环神经网络的字符级语言模型><strong>基于循环神经网络的字符级语言模型</strong></a></li><li><a href=#one-hot-encoding-独热编码><strong>One-Hot Encoding 独热编码</strong></a></li><li><a href=#梯度裁剪gradient-clipping><strong>梯度裁剪（Gradient Clipping）</strong></a></li><li><a href=#解码-decoding><strong>解码 (Decoding)</strong></a></li></ul></li><li><a href=#rnn中的反向传播算法><strong>RNN中的反向传播算法</strong></a><ul><li><a href=#反向传播的细节><strong>反向传播的细节</strong></a></li></ul></li><li><a href=#简单循环神经网络实现><strong>简单循环神经网络实现</strong></a></li></ul></nav></div></aside></main></body></html>