<!doctype html><html lang=en-us dir=ltr><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  分词和词嵌入（Tokenization and Word Embeddings）
  #


  分词（Tokenization）
  #


  分词的基本概念
  #

⁉️ 什么是 Tokenization？为什么它对LLM至关重要？
  
什么是 Tokenization？为什么它对LLM至关重要？
Tokenization（分词）是将文本拆分成更小的单元（tokens）的过程，这些单元可以是单词、子词或字符。在自然语言处理中，分词是文本预处理的重要步骤。他直接影响模型对语义的理解能力、计算效率和内存占用。

Example：句子 “Hello, world!” 可被切分为 ["Hello", ",", "world", "!"]（基于空格和标点）。


  Note：简而言之，Tokenization 是一个 将输入文本拆解为 tokens（可能是词、子词或字符）的过程，而词表 是一个 包含所有可能 tokens 的集合，它定义了 token 到数字 ID 的映射。

  


⁉️ 解释什么是 Encoding？Text Encoding，Feature Encoding，Position Encoding 分别是什么？
  
解释什么是 Encoding？
Text Encoding 主要做的事情是 把文本转换成结构化的、可索引的格式，这样后续的模型或者算法可以进行查询和计算，这个过程类似于构建一个 “字典”（vocabulary），把文本转换成可以查询的 ID 表示。除了构建可查询的字典。所以说 分词（tokenization）可以理解为 encoding 的子步骤或前置步骤。
除了 Text Encoding，Encoding 还可以分为：

Text Encoding / Token Encoding - 输入编码 （如 BPE, WordPiece, Token → ID）
Feature Encoding - 特征构建 （如 TF-IDF, BoW, 词频向量等）
Position / Structural Encoding - 结构性编码 （如 Position Encoding in Transformers）

一些简单的 Feature Encoding 包括：'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="http://localhost:1313/docs/deep-learning/attention-and-transformers/tokenization-and-word-embeddings/"><meta property="og:site_name" content="Followblindly"><meta property="og:title" content="Tokenization and Word Embeddings"><meta property="og:description" content='分词和词嵌入（Tokenization and Word Embeddings） # 分词（Tokenization） # 分词的基本概念 # ⁉️ 什么是 Tokenization？为什么它对LLM至关重要？ 什么是 Tokenization？为什么它对LLM至关重要？ Tokenization（分词）是将文本拆分成更小的单元（tokens）的过程，这些单元可以是单词、子词或字符。在自然语言处理中，分词是文本预处理的重要步骤。他直接影响模型对语义的理解能力、计算效率和内存占用。
Example：句子 “Hello, world!” 可被切分为 ["Hello", ",", "world", "!"]（基于空格和标点）。 Note：简而言之，Tokenization 是一个 将输入文本拆解为 tokens（可能是词、子词或字符）的过程，而词表 是一个 包含所有可能 tokens 的集合，它定义了 token 到数字 ID 的映射。
⁉️ 解释什么是 Encoding？Text Encoding，Feature Encoding，Position Encoding 分别是什么？ 解释什么是 Encoding？ Text Encoding 主要做的事情是 把文本转换成结构化的、可索引的格式，这样后续的模型或者算法可以进行查询和计算，这个过程类似于构建一个 “字典”（vocabulary），把文本转换成可以查询的 ID 表示。除了构建可查询的字典。所以说 分词（tokenization）可以理解为 encoding 的子步骤或前置步骤。
除了 Text Encoding，Encoding 还可以分为：
Text Encoding / Token Encoding - 输入编码 （如 BPE, WordPiece, Token → ID） Feature Encoding - 特征构建 （如 TF-IDF, BoW, 词频向量等） Position / Structural Encoding - 结构性编码 （如 Position Encoding in Transformers） 一些简单的 Feature Encoding 包括：'><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><title>Tokenization and Word Embeddings | Followblindly</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=http://localhost:1313/docs/deep-learning/attention-and-transformers/tokenization-and-word-embeddings/><link rel=stylesheet href=/book.min.bff4c6870ba26abd815329272c8df8231704f9ac54bee84c3ef1f649e394d14f.css integrity="sha256-v/TGhwuiar2BUyknLI34IxcE+axUvuhMPvH2SeOU0U8=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.947574131340145a88d41519def1be16086421292e611565c0d45c05dd78e4db.js integrity="sha256-lHV0ExNAFFqI1BUZ3vG+FghkISkuYRVlwNRcBd145Ns=" crossorigin=anonymous></script><link rel=alternate type=application/rss+xml href=http://localhost:1313/docs/deep-learning/attention-and-transformers/tokenization-and-word-embeddings/index.xml title=Followblindly></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/As.png alt=Logo class=book-icon><span>Followblindly</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><span>Python Basics</span><ul><li><a href=/docs/python-basics/python-fundamentals/>Python Fundamentals</a><ul></ul></li><li><input type=checkbox id=section-b0810fa42fa69050cb4968ec00fbf282 class=toggle>
<label for=section-b0810fa42fa69050cb4968ec00fbf282 class="flex justify-between"><a href=/docs/python-basics/leetcode/>Leetcode Notes</a></label><ul><li><a href=/docs/python-basics/leetcode/practice-history/>Practice History</a><ul></ul></li></ul></li></ul></li><li class=book-section-flat><input type=checkbox id=section-7e28d5ac3e9843e0deb580be9504447e class=toggle>
<label for=section-7e28d5ac3e9843e0deb580be9504447e class="flex justify-between"><a role=button>Common Libraries</a></label><ul><li><a href=/docs/common-libraries/numpy/>NumPy</a><ul></ul></li><li><a href=/docs/common-libraries/pandas/>Pandas</a><ul></ul></li><li><a href=/docs/common-libraries/pytorch/>PyTorch</a><ul></ul></li></ul></li><li class=book-section-flat><span>Machine Learning</span><ul><li><a href=/docs/machine-learning/machine-learning-basics/>Machine Learning Basics</a><ul></ul></li><li><a href=/docs/machine-learning/data-preprocessing/>Data Preprocessing</a><ul></ul></li><li><input type=checkbox id=section-89d4dd5d95507b817cf74368af5982ba class=toggle>
<label for=section-89d4dd5d95507b817cf74368af5982ba class="flex justify-between"><a href=/docs/machine-learning/supervised-learning/>Supervised Learning</a></label><ul><li><a href=/docs/machine-learning/supervised-learning/linear-regression/>Linear Regression</a><ul></ul></li><li><a href=/docs/machine-learning/supervised-learning/logistic-regression/>Logistic Regression</a><ul></ul></li></ul></li><li><input type=checkbox id=section-452d9bf73a55e6b3d947afcc89364ff4 class=toggle>
<label for=section-452d9bf73a55e6b3d947afcc89364ff4 class="flex justify-between"><a href=/docs/machine-learning/unsupervised-learning/>Unsupervised Learning</a></label><ul></ul></li><li><a href=/docs/machine-learning/regularization/>Regularization</a><ul></ul></li><li><a href=/docs/machine-learning/optimization/>Optimization</a><ul></ul></li><li><a href=/docs/machine-learning/computational-performance/>Computational Performance</a><ul></ul></li></ul></li><li class=book-section-flat><span>Deep Learning</span><ul><li><a href=/docs/deep-learning/perceptrons-and-neural-network/>Perceptrons and Neural Network</a><ul></ul></li><li><input type=checkbox id=section-d0dd931d60033c220ecd4cd60b7c9170 class=toggle>
<label for=section-d0dd931d60033c220ecd4cd60b7c9170 class="flex justify-between"><a href=/docs/deep-learning/convolutional-neural-networks/>Convolutional Neural Networks</a></label><ul><li><a href=/docs/deep-learning/convolutional-neural-networks/modern-convolutional-neural-networks/>Modern Convolutional Neural Networks</a><ul></ul></li></ul></li><li><input type=checkbox id=section-a3019bfa8037cc33ed6405d1589b6219 class=toggle>
<label for=section-a3019bfa8037cc33ed6405d1589b6219 class="flex justify-between"><a href=/docs/deep-learning/recurrent-neural-networks/>Recurrent Neural Networks</a></label><ul><li><a href=/docs/deep-learning/recurrent-neural-networks/modern-recurrent-neural-networks/>Modern Recurrent Neural Networks</a><ul></ul></li></ul></li><li><input type=checkbox id=section-0a43584c16258b228ae9aa8d70efc320 class=toggle checked>
<label for=section-0a43584c16258b228ae9aa8d70efc320 class="flex justify-between"><a href=/docs/deep-learning/attention-and-transformers/>Attention and Transformers</a></label><ul><li><a href=/docs/deep-learning/attention-and-transformers/tokenization-and-word-embeddings/ class=active>Tokenization and Word Embeddings</a><ul></ul></li><li><a href=/docs/deep-learning/attention-and-transformers/transformer-architecture/>Transformer Architecture</a><ul></ul></li><li><a href=/docs/deep-learning/attention-and-transformers/modern-large-language-models/>Modern LLMs and Pre-Training</a><ul></ul></li><li><a href=/docs/deep-learning/attention-and-transformers/post-training-large-language-models/>Post-training LLMs</a><ul></ul></li><li><a href=/docs/deep-learning/attention-and-transformers/large-language-models-optimization/>Large Language Models Optimization</a><ul></ul></li><li><a href=/docs/deep-learning/attention-and-transformers/multimodal-large-language-models/>Multimodal Large Language Models</a><ul></ul></li></ul></li><li><input type=checkbox id=section-92e8358c45c96009753cf4227e9daea8 class=toggle>
<label for=section-92e8358c45c96009753cf4227e9daea8 class="flex justify-between"><a href=/docs/deep-learning/llm-pipelines/>LLM Pipelines</a></label><ul><li><a href=/docs/deep-learning/llm-pipelines/llm-hardware-and-model-size/>LLM Hardware and Model Size</a><ul></ul></li><li><a href=/docs/deep-learning/llm-pipelines/large-scale-pretraining-with-transformers/>Large-Scale Pretraining with Transformers</a><ul></ul></li><li><a href=/docs/deep-learning/llm-pipelines/llm-inference-and-deployment/>LLM Inference and Deployment</a><ul></ul></li></ul></li></ul></li><li class=book-section-flat><input type=checkbox id=section-8b0266d7d6ac3da61ec6acf4e97681ca class=toggle>
<label for=section-8b0266d7d6ac3da61ec6acf4e97681ca class="flex justify-between"><a role=button>Others</a></label><ul><li><a href=/docs/others/interview-preparation-guide/>Interview Preparation Guide</a><ul></ul></li></ul></li></ul><ul><li><a href=/posts/>Blog</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Tokenization and Word Embeddings</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><link rel=stylesheet href=/css/prism-one-dark.css><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#分词tokenization><strong>分词（Tokenization）</strong></a><ul><li><a href=#分词的基本概念><strong>分词的基本概念</strong></a></li><li><a href=#分词方法bpe-wordpiece-sentencepiece><strong>分词方法（BPE, WordPiece, SentencePiece）</strong></a></li></ul></li><li><a href=#词嵌入word-embeddings><strong>词嵌入（Word Embeddings）</strong></a><ul><li><a href=#词嵌入的基本概念><strong>词嵌入的基本概念</strong></a></li><li><a href=#静态词向量word2vecskip-gramcbowglove><strong>静态词向量（Word2Vec，Skip-gram，CBOW，GloVe）</strong></a></li><li><a href=#transformer-中的-word-embedding><strong>Transformer 中的 Word Embedding</strong></a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=分词和词嵌入tokenization-and-word-embeddings><strong>分词和词嵌入（Tokenization and Word Embeddings）</strong>
<a class=anchor href=#%e5%88%86%e8%af%8d%e5%92%8c%e8%af%8d%e5%b5%8c%e5%85%a5tokenization-and-word-embeddings>#</a></h1><h2 id=分词tokenization><strong>分词（Tokenization）</strong>
<a class=anchor href=#%e5%88%86%e8%af%8dtokenization>#</a></h2><h3 id=分词的基本概念><strong>分词的基本概念</strong>
<a class=anchor href=#%e5%88%86%e8%af%8d%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5>#</a></h3><details><summary><strong class=custom-details-title>⁉️ 什么是 Tokenization？为什么它对LLM至关重要？</strong></summary><div class=markdown-inner><h2><b>什么是 Tokenization？为什么它对LLM至关重要？</b></h2><p>Tokenization（分词）是将文本拆分成更小的单元（tokens）的过程，这些单元可以是单词、子词或字符。在自然语言处理中，分词是文本预处理的重要步骤。他直接影响模型对语义的理解能力、计算效率和内存占用。</p><ul><li><strong>Example</strong>：句子 “Hello, world!” 可被切分为 <code>["Hello", ",", "world", "!"]</code>（基于空格和标点）。</li></ul><blockquote class="book-hint warning"><p><strong>Note</strong>：简而言之，Tokenization 是一个 <strong>将输入文本拆解为 tokens（可能是词、子词或字符）的过程</strong>，而<strong>词表</strong> 是一个 <strong>包含所有可能 tokens 的集合</strong>，它定义了 token 到数字 ID 的映射。</p></blockquote></div></details><hr><details><summary><strong class=custom-details-title>⁉️ 解释什么是 Encoding？Text Encoding，Feature Encoding，Position Encoding 分别是什么？</strong></summary><div class=markdown-inner><h2><b>解释什么是 Encoding？</b></h2><p>Text Encoding 主要做的事情是 <strong>把文本转换成结构化的、可索引的格式，这样后续的模型或者算法可以进行查询和计算</strong>，这个过程类似于构建一个 “字典”（vocabulary），把文本转换成可以查询的 ID 表示。除了构建可查询的字典。所以说 <strong>分词（tokenization）可以理解为 encoding 的子步骤或前置步骤。</strong></p><p>除了 Text Encoding，Encoding 还可以分为：</p><ul><li><strong>Text Encoding / Token Encoding - 输入编码</strong> （如 BPE, WordPiece, Token → ID）</li><li><strong>Feature Encoding - 特征构建</strong> （如 TF-IDF, BoW, 词频向量等）</li><li><strong>Position / Structural Encoding - 结构性编码</strong> （如 Position Encoding in Transformers）</li></ul><p>一些简单的 <strong>Feature Encoding</strong> 包括：</p><ul><li><p><a href=https://followb1ind1y.github.io/docs/machine-learning/data-preprocessing/#%e7%8b%ac%e7%83%ad%e7%bc%96%e7%a0%81one-hot-encoding>独热编码（One-Hot Encoding）</a></p></li><li><p><a href=https://followb1ind1y.github.io/docs/machine-learning/data-preprocessing/#bag-of-words-bow>Bag-of-Words (BoW)</a></p></li><li><p><a href=https://followb1ind1y.github.io/docs/machine-learning/data-preprocessing/#%e7%8b%ac%e7%83%ad%e7%bc%96%e7%a0%81one-hot-encoding>TF-IDF</a></p></li></ul><blockquote class="book-hint warning"><p><strong>Note</strong>：<strong>Text Encoding ≈ 构建词表 + 确定如何把文本映射成 token</strong>。也就是说，“encoding”这个词在 tokenizer.encode() 这种 API 里，通常指的是：</p><ul><li>把原始字符串 → token（比如 BPE 的子词切分）</li><li>把 token → token ID（索引在词表中的位置）</li></ul><p>这个过程中依赖词表（vocabulary），所以可以说“构建词表是 encoding 的核心部分之一”。</p><p><strong>Tokenization 是 encoding 的子步骤，Tokenizer 是执行这套 encoding 规则的工具。</strong></p></blockquote></div></details><hr><details><summary><strong class=custom-details-title>⁉️ 词表大小对模型性能的影响？</strong></summary><div class=markdown-inner><h2><b>词表大小对模型性能的影响？</b></h2><p><strong>词表的大小决定了模型可识别的唯一 Token 数量</strong>，比如 LLaMA 采用了 32k 的词表，而 GPT-2 使用了 50k 词表。较大的词表（包含子词、常用词，甚至整个句子）允许模型以更少的 Token 表示相同文本，<strong>提高表达能力，但也增加了参数规模和计算复杂度</strong>；而较小的词表（只包含字符 a-z, 标点等）则 <strong>减少了计算需求，但可能导致序列变长，进而影响训练效率</strong>。因此，在预训练阶段，词表大小的选择会直接影响模型的记忆能力、计算成本以及推理速度。</p><blockquote class="book-hint warning"><p><strong>Note</strong>：词表（Vocabulary）既可以直接使用预训练模型提供的标准词表，也可以根据自己的数据集重新训练一个词表，具体取决于应用需求：</p><ol><li><strong>直接使用预训练词表</strong>：如 GPT-3、LLaMA、T5 等开源模型的 Tokenizer 已经基于大规模文本语料（如 Common Crawl、Wikipedia）训练了词表，并随模型一起发布。直接使用这些词表能够确保与原始模型的 Token 方式一致，避免 Token 不匹配导致的性能下降。这种方法 <strong>适用于大多数 NLP 任务</strong>，特别是在迁移学习（Transfer Learning）场景下。</li><li><strong>基于自有数据训练新词表</strong>：如果 <strong>目标领域与通用 NLP 语料差异较大（如医学、法律、金融等专业领域），或者需要支持特定语言（如低资源语言或多语言任务）</strong>，可以使用 SentencePiece（支持 BPE、Unigram）或 Hugging Face Tokenizers 来从头训练词表。训练时通常会调整 词表大小（Vocabulary Size），使其适配目标任务。较大的词表可以减少 OOV（Out-Of-Vocabulary）问题，而较小的词表能减少计算复杂度，提高推理速度。</li></ol></blockquote></div></details><hr><details><summary><strong class=custom-details-title>⁉️ Tokenizer 在实际模型预训练阶段是如何被使用的？</strong></summary><div class=markdown-inner><h2><b>Tokenizer 在实际模型预训练阶段是如何被使用的？</b></h2><p><strong>Tokenizer（分词器）</strong> 的主要作用是 <strong>将原始文本转换为模型可理解的离散数值表示</strong>，即 <strong>Token ID（标记序列）</strong>。这个过程通常包括分词（Tokenization）、映射（Mapping to Vocabulary） 和 填充/截断（Padding/Truncation）。在分词时，不同的 Tokenizer会根据预定义的 <strong>词表（Vocabulary）</strong> 将文本拆分成最优的子词单元。</p><blockquote class="book-hint warning"><p>以 Hugging Face 的 tokenizer 或 OpenAI 的 tokenizer 为例，它通常会完成以下几个步骤：</p><ol><li><strong>预处理</strong>：清理文本，比如去掉空格、标准化 Unicode 等</li><li><strong>分词（Tokenization）</strong>：比如把句子 “ChatGPT 是谁？” 切成像 <code>['Chat', 'G', 'PT', ' 是', '谁', '?']</code></li><li><strong>映射成 ID（Encoding）</strong>：把这些 token 映射为对应的词汇表索引，例如 <code>[1345, 67, 9801, 345, 26, 9]</code></li><li><strong>加入特殊 token</strong>：比如 <code>[CLS]</code>、<code>[SEP]</code> 或 <code>&lt;|startoftext|></code> 这样的符号</li><li><strong>返回 tensor</strong>：供模型输入使用</li></ol></blockquote></div></details><hr><details><summary><strong class=custom-details-title>⁉️ Tokenization 如何影响模型性能？</strong></summary><div class=markdown-inner><h2><b>Tokenization 如何影响模型性能？</b></h2><ul><li><p><strong>词表过大</strong>：增加内存消耗，降低计算效率（Softmax 计算成本高）。</p></li><li><p><strong>词表过小</strong>：导致长序列和语义碎片化（如切分为无意义的子词）。</p></li><li><p><strong>语言适配性</strong>：中/日/韩等非空格语言需要特殊处理（如 SentencePiece）。</p></div></li></ul></details><hr><details><summary><strong class=custom-details-title>⁉️ 如何为多语言模型设计Tokenization方案？</strong></summary><div class=markdown-inner><h2><b>如何为多语言模型设计 Tokenization 方案？</b></h2><ul><li><p><strong>统一词表</strong>：使用 SentencePiece 跨语言训练（如mBERT）。</p></li><li><p><strong>平衡语种覆盖</strong>：根据语种数据量调整合并规则，避免小语种被淹没。</p></li><li><p><strong>特殊标记</strong>：添加语言ID（如 <code>[EN]</code>、<code>[ZH]</code>）引导模型区分语言。</p></div></li></ul></details><h3 id=分词方法bpe-wordpiece-sentencepiece><strong>分词方法（BPE, WordPiece, SentencePiece）</strong>
<a class=anchor href=#%e5%88%86%e8%af%8d%e6%96%b9%e6%b3%95bpe-wordpiece-sentencepiece>#</a></h3><details><summary><strong class=custom-details-title>⁉️ 常见的 Tokenization 方法有哪些？它们的区别是什么？</strong></summary><div class=markdown-inner><h2><b>常见的 Tokenization 方法有哪些？它们的区别是什么</b></h2><ul><li><p><strong>Word-level</strong>：按词切分（如 <code>“natural language processing” → ["natural", "language", "processing"]</code>），但词表大且难以处理未登录词（OOV）。</p></li><li><p><strong>Subword-level（主流方法）</strong>：</p><ul><li><strong>BPE（Byte-Pair Encoding）</strong>：通过合并高频字符对生成子词（如GPT系列使用）。</li><li><strong>WordPiece</strong>：类似BPE，但基于概率合并（如BERT使用）。</li><li><strong>SentencePiece</strong>：无需预分词，直接处理原始文本（如T5使用）。</li></ul></li><li><p><strong>Character-level</strong>：按字符切分，词表极小但序列长且语义建模困难。</p></div></li></ul></details><hr><details><summary><strong class=custom-details-title>⁉️ BPE算法的工作原理是什么？请举例说明。</strong></summary><div class=markdown-inner><h2><b>BPE 算法的工作原理是什么？请举例说明。</b></h2><p>BPE（Byte Pair Encoding）是一种子词分割（Subword Segmentation）算法，核心思想是基于 <strong>统计频率</strong> 的合并（Merge frequent pairs）。</p><ul><li><strong>工作原理</strong>：<ol><li>统计字符对（Byte Pair）频率，找到最常见的相邻字符对。<pre tabindex=0><code>[&#34;l&#34;, &#34;o&#34;, &#34;w&#34;, &#34; &#34;, &#34;l&#34;, &#34;o&#34;, &#34;w&#34;, &#34;e&#34;, &#34;r&#34;, &#34; &#34;, &#34;n&#34;, &#34;e&#34;, &#34;w&#34;, &#34;e&#34;, &#34;s&#34;, &#34;t&#34;]
</code></pre></li><li>合并最频繁的字符对，形成新的子词单元。<pre tabindex=0><code>(&#34;l&#34;, &#34;o&#34;) -&gt; 2次
(&#34;o&#34;, &#34;w&#34;) -&gt; 2次
    ...
</code></pre>（第一次）合并 <code>("l", "o") → "lo"</code>：<pre tabindex=0><code>[&#34;lo&#34;, &#34;w&#34;, &#34;lo&#34;, &#34;w&#34;, &#34;er&#34;, &#34;n&#34;, &#34;e&#34;, &#34;w&#34;, &#34;e&#34;, &#34;st&#34;]
</code></pre>（第二次）合并 <code>("lo", "w") → "low"</code><pre tabindex=0><code>[&#34;low&#34;, &#34;low&#34;, &#34;er&#34;, &#34;n&#34;, &#34;e&#34;, &#34;w&#34;, &#34;e&#34;, &#34;st&#34;]
</code></pre></li><li>重复步骤 1 和 2，直到达到预定的子词词汇量。<pre tabindex=0><code>[&#34;low&#34;, &#34;lower&#34;, &#34;er&#34;, &#34;newest&#34;]
</code></pre><pre tabindex=0><code>vocab = {&#34;low&#34;: 100, &#34;lower&#34;: 101, &#34;er&#34;: 102, &#34;newest&#34;: 103}
</code></pre></li></ol></li></ul><p>BPE的优点是它 <strong>能够有效地处理未登录词</strong>，并且在处理长尾词（rare words）时表现良好。比如，词”unhappiness”可以被分解为”un” + “happiness”，而不是完全看作一个新的词。</p></div></details><hr><details><summary><strong class=custom-details-title>⁉️ WordPiece 算法的工作原理是什么？请举例说明。</strong></summary><div class=markdown-inner><h2><b>WordPiece 算法的工作原理是什么？请举例说明</b></h2><p>WordPiece 的核心理念与BPE相似，但合并策略更注重语义完整性。其训练过程同样从基础单元（如字符）开始，但选择合并的标准并非单纯依赖频率，而是通过 <strong>计算合并后对语言模型概率的提升幅度</strong>，优先保留能够增强语义连贯性的子词。</p><ul><li>假设语言模型的目标是最大化训练数据的似然概率，在 WordPiece 中，简化为 通过子词频率估计概率（即一元语言模型）。通过计算合并后对语言模型概率的提升幅度进行合并：</li></ul><link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script><script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><span>\[
\begin{equation}
P(S)≈ \prod^{n}_{i=1}P(s_i)
\end{equation}
\]</span><blockquote class="book-hint warning"><ul><li><strong>直观理解</strong>：若两个子词 <code>u</code> 和 <code>v</code> 经常紧密共现，合并为 <code>z=uv</code> 后，语言模型对 <code>z</code> 的概率估计应比单独处理 <code>u</code> 和 <code>v</code> 更准确，从而提升整体数据的似然。<ul><li>统计所有相邻子词对 <code>(u, v)</code> 在训练数据中的出现次数 <code>count(u, v)</code>。</li><li>同时记录每个子词 <code>u</code> 的独立出现次数 <code>count(u)</code> 和 <code>count(v)</code>。</li><li>当合并 <code>(u, v)</code> 为 <code>z</code> 后：<ul><li>原概率：<code>P(u)×P(v∣u)</code></li><li>新概率：<code>P(z)</code></li><li>若合并后 <code>P(z)>P(u)×P(v)</code>，则整体似然提升。</li></ul></li></ul></li></ul></blockquote><ul><li><strong>工作原理</strong>：<ol><li><p>与BPE类似，首先将所有词分解为最小的单位（如字符）。</p><pre tabindex=0><code>[&#34;l&#34;, &#34;o&#34;, &#34;w&#34;, &#34; &#34;, &#34;l&#34;, &#34;o&#34;, &#34;w&#34;, &#34;e&#34;, &#34;r&#34;, &#34; &#34;, &#34;n&#34;, &#34;e&#34;, &#34;w&#34;, &#34;e&#34;, &#34;s&#34;, &#34;t&#34;, &#34; &#34;, &#34;w&#34;, &#34;i&#34;, &#34;d&#34;, &#34;e&#34;, &#34;s&#34;, &#34;t&#34;]
</code></pre></li><li><p>统计所有可能的字符对（或子词对）在文本中的共现频率。</p></li><li><p>合并字符对，选择合并后能 <strong>最大化语言模型似然概率</strong> 的字符对。具体公式为：选择使 <code>score = freq(pair) / (freq(first) * freq(second)) </code>最大的字符对（<strong>与 BPE 不同，BPE 仅选择频率最高的对</strong>）。每次合并对语言模型概率提升最大的合并组合。</p><p>这里的 <code>##</code> 表示这个 token 只能作为后缀出现，不会单独存在。</p><pre tabindex=0><code>{&#34;low&#34;, &#34;##er&#34;, &#34;##ing&#34;, &#34;new&#34;, &#34;##est&#34;, &#34;wide&#34;, &#34;##st&#34;}
</code></pre></li><li><p>重复合并得分最高的字符对，直到达到预设的词汇表大小。</p><pre tabindex=0><code>vocab = {&#34;low&#34;: 100, &#34;##er&#34;: 101, &#34;##ing&#34;: 102, &#34;new&#34;: 103, &#34;##est&#34;: 104, &#34;wide&#34;: 105, &#34;##st&#34;: 106}
</code></pre></li></ol></li></ul><p>WordPiece 通过最大化语言模型概率合并子词，<strong>生成的子词更贴合语义需求</strong>。但计算复杂度更高，需多次评估合并得分。</p><ul><li><p>若需模型捕捉深层语义（如预训练任务），优先选择 WordPiece。</p></li><li><p>若需快速处理大规模数据且词汇表灵活，BPE 更合适。</p></div></li></ul></details><hr><details><summary><strong class=custom-details-title>⁉️ SentencePiece 算法的工作原理是什么？请举例说明。</strong></summary><div class=markdown-inner><h2><b>SentencePiece 算法的工作原理是什么？请举例说明</b></h2><p>SentencePiece 是一种无监督的子词分割算法，其核心创新在于直接处理原始文本（包括空格和特殊符号），无需依赖预分词步骤。<strong>它支持两种底层算法：BPE 或 基于概率的Unigram Language Model</strong>。训练时，SentencePiece 将空格视为普通字符 <code>_</code>，可 <strong>直接处理多语言混合文本（如中英文混杂）</strong>，并自动学习跨语言的统一子词划分规则。</p><ul><li><strong>Example：</strong> <code>"Hello世界" → 编码为 ["▁He", "llo", "▁世", "界"]。</code></li></ul><p>SentencePiece 支持多语言（Multilingual）无需调整，统一处理空格与特殊符号。这一特性使其在需要多语言支持的场景（如T5模型）中表现突出，同时简化了数据处理流程，特别适合处理社交媒体文本等非规范化输入。</p></div></details><hr><details><summary><strong class=custom-details-title>⁉️ 如何处理未登录词（OOV）？</strong></summary><div class=markdown-inner><h2><b>如何处理未登录词（OOV）？</b></h2><ul><li><p><strong>子词切分</strong>：将OOV（Out-of-Vocabulary）词拆分为已知子词（如 <code>“tokenization” → ["token", "ization"]</code>）。</p></li><li><p><strong>回退策略</strong>：使用特殊标记（如 <code>[UNK]</code>），但会损失信息。</p></li><li><p><strong>动态更新词表</strong>：在增量训练时扩展词表。</p></div></li></ul></details><hr><h2 id=词嵌入word-embeddings><strong>词嵌入（Word Embeddings）</strong>
<a class=anchor href=#%e8%af%8d%e5%b5%8c%e5%85%a5word-embeddings>#</a></h2><h3 id=词嵌入的基本概念><strong>词嵌入的基本概念</strong>
<a class=anchor href=#%e8%af%8d%e5%b5%8c%e5%85%a5%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5>#</a></h3><details><summary><strong class=custom-details-title>⁉️ 什么是词嵌入（Word Embeddings）？为什么它重要？</strong></summary><div class=markdown-inner><h2><b>什么是词嵌入（Word Embeddings）？为什么它重要？</b></h2><p>在自然语言处理中，Embedding（词嵌入）是将 <strong>离散的文本数据（如单词、短语或句子）映射到一个连续的、低维度的向量空间（vector space）的过程</strong>。他的作用包括：</p><ol><li><strong>捕捉语义关系（Semantic Relationships）</strong>：能表示同义词、类比关系（如 king - man + woman ≈ queen）。</li><li><strong>降维（Dimensionality Reduction）</strong>：将高维的 <strong>独热编码（One-hot Encoding）</strong> 转换为低维密集向量，提高计算效率。</li><li><strong>解决稀疏性问题（Handling Sparsity）</strong>：相比于独热编码，词嵌入具有更好的泛化能力（Generalization）。</li></ol><blockquote class="book-hint warning"><p><strong>Note：</strong> 词嵌入可以理解为是把普通的词表对应关系 <strong>投影到一个高维空间</strong>，所以可以通过学习获得词之间的关系信息。<strong>也可以将词嵌入（Embedding）看作是提供并增加了模型可以训练的参数</strong>。</p><p>在词嵌入模型训练之前，<strong>所有的词向量通常是随机初始化的</strong>，这些初始的词向量并没有语义上的意义，实际上它们只是一些 <strong>随机数</strong>。但通过训练，模型能够根据上下文和语料库中的信息，逐渐学习到每个单词的有效表示。在训练过程中，模型调整这些词向量，使得相似含义的词语具有相似的向量表示，进而反映出词语之间的语义关系。</p></blockquote></div></details><hr><details><summary><strong class=custom-details-title>⁉️ 静态词向量 和 上下文动态词向量的区别？</strong></summary><div class=markdown-inner><h2><b>静态词向量 和 上下文动态词向量的区别？</b></h2><ul><li><p><strong>静态词向量（Static Word Embeddings）</strong> 的核心特点是 <strong>无论词语出现在何种上下文中，其向量表示均保持不变</strong>。这类方法通过大规模语料训练，捕捉词语间的语义和语法关系。静态词向量的优势在于训练高效、资源消耗低，且生成的向量可直观反映语义相似性（如“猫”和“狗”向量接近）；但其 <strong>局限性是无法处理多义词</strong>（如“苹果”在“水果”和“手机”场景中的不同含义），因为 <strong>每个词仅对应单一向量</strong>。代表模型包括：Word2Vec, GloVe。</p></li><li><p><strong>上下文动态词向量（Contextual Word Embeddings）</strong>：静态嵌入虽然可以表示词语的语义，但它们无法根据上下文动态调整，例如 “bank” 在 “river bank” 和 “bank account” 里的含义不同。而 动态词嵌入 解决了这个问题，代表性模型包括 ELMo、BERT 和 GPT。</p></div></li></ul></details><hr><h3 id=静态词向量word2vecskip-gramcbowglove><strong>静态词向量（Word2Vec，Skip-gram，CBOW，GloVe）</strong>
<a class=anchor href=#%e9%9d%99%e6%80%81%e8%af%8d%e5%90%91%e9%87%8fword2vecskip-gramcbowglove>#</a></h3><details><summary><strong class=custom-details-title>⁉️ 解释 Word2Vec 的两种模型：Skip-gram 和 CBOW。</strong></summary><div class=markdown-inner><h2><b>解释 Word2Vec 的两种模型：Skip-gram 和 CBOW。</b></h2><ul><li><p><strong>跳元模型（Skip-gram）</strong> 假设 一个词可以用来在文本序列中生成其周围的单词。以文本序列 <code>“the”“man”“loves”“his”“son”</code> 为例。假设中心词选择 <code>“loves”</code>，并将上下文窗口设置为2，给定中心词 <code>“loves”</code>，跳元模型考虑生成上下文词 <code>“the”“man”“him”“son”</code> 的条件概率。最大化给定中心词时上下文词的条件概率：
$$
max{\sum log P(context_w|center_w)}
$$
Word2Vec 的核心是 <strong>一个浅层神经网络（Shallow Neural Network）</strong>，由一个输入层、一个隐藏层（线性变换层）、一个输出层（Softmax 或其他采样方法）组成:</p><ol><li><strong>输入示例</strong>：<ul><li>句子：<code>“I love natural language processing.”</code></li><li>若窗口大小为1，中心词为 <code>“natural”</code>，则上下文词为 <code>“love”</code> 和 <code>“language”</code>。</li></ul></li><li><strong>输入通过 One-Hot 编码 表示为一个稀疏向量</strong>。例如，若词汇表为 <code>["cat", "dog", "fish"]</code>，则<code>“dog”</code> 的输入编码为 <code>[0, 1, 0]</code>。</li><li><strong>输入层到隐藏层</strong>：输入向量与 输入权重矩阵 <code>W_{in}</code>（维度为 <code>V×d</code>，<code>V</code> 是词汇表大小，<code>d</code> 是词向量维度）相乘，得到中心词的嵌入向量 <code>v_i</code>。<br>$$
v_i=W_{in}⋅OneHot(w)。
$$</li><li><strong>通过 输出权重矩阵 <code>W_{out}</code>（维度为 <code>d×V</code>）将隐层向量映射到输出概率</strong>：
$$
u_i = W_{out}⋅v_i。
$$</li><li>使用 Softmax 归一化，通过梯度下降优化词向量，使得上下文词的概率最大化。</li></ol><p><strong>跳元模型（Skip-gram）特点</strong>：</p><ul><li><strong>擅长捕捉低频词</strong>：通过中心词预测多个上下文，低频词有更多训练机会。</li><li><strong>训练速度较慢</strong>：输出层需计算多个上下文词的概率。</li></ul></li></ul><blockquote class="book-hint warning"><p><strong>Note：</strong> 训练后，<strong>输入矩阵中的向量 <code>v_i</code> 即为词的低维表示。输入向量更聚焦中心词语义，输出向量辅助建模上下文关系，最终通常只使用输入向量。</strong></p></blockquote><hr><ul><li><p><strong>连续词袋（CBOW）</strong> 与 Skip-gram 相对，CBOW 的训练过程是 <strong>给定上下文词，预测中心词</strong>。这里的目标是将多个上下文词的向量平均起来，并通过它们来预测中心词。在文本序列 <code>“the”“man”“loves”“his”“son”</code> 中，在 <code>“loves”</code> 为中心词且上下文窗口为 2 的情况下，连续词袋模型考虑基于上下文词 <code>“the”“man”“him”“son”</code> 生成中心词 <code>“loves”</code> 的条件概率。最大化给定上下文时中心词的条件概率：
$$
max{\sum log P(center_w|context_w)}
$$
连续词袋（CBOW）的训练细节与 跳元模型（Skip-Gram）大部分类似，但是在输入 One-Hot 编码表示时，跳元模型（Skip-Gram）将中心词进行 One-Hot 编码，<strong>而连续词袋（CBOW）将上下文词进行 One-Hot 编码并取平均值</strong>。 例如，中心词为 <code>“natural”</code>，上下文词为 <code>“love”</code> 和 <code>“language”</code> 。输入为 <code>[0, 1, 0, 0, 0]</code>（<code>“love”</code>）和 <code>[0, 0, 0, 1, 0]</code>（<code>“language”</code>）的平均向量 <code>[0, 0.5, 0, 0.5, 0]</code>。此外，输出概率通过 Softmax 计算公式也有不同。</p><p><strong>连续词袋（CBOW）特点</strong>：</p><ul><li><strong>训练速度快</strong>：输入为多个词的均值向量，计算效率高。</li><li><strong>对高频词建模更好</strong>：上下文词共同贡献中心词预测。</li></ul></li></ul><blockquote class="book-hint warning"><p><strong>Note:</strong> CBOW 也是通过类似浅层神经网络学习关系。在实践中同样也是把词汇表投影到高维空间（<code>nn.Embedding</code>）。利用周围词预测中心词的原理训练其中的参数。<strong>注意，Skip-gram 和 CBOW 学习的都是 <code>nn.Embedding</code> 映射的 matrix，只是训练的方法和训练目标（loss）不一样。</strong></p><p>其过程可以通过下面的 code 理解：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 1. 查找词向量</span>
</span></span><span style=display:flex><span>embedded <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>embeddings(context_words)  <span style=color:#75715e># (batch_size, context_size, embedding_dim)</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span><span style=color:#75715e># 2. 计算上下文词向量的平均值</span>
</span></span><span style=display:flex><span>embedded <span style=color:#f92672>=</span> embedded<span style=color:#f92672>.</span>mean(dim<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)  <span style=color:#75715e># (batch_size, embedding_dim)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3. 通过全连接层计算每个单词的概率</span>
</span></span><span style=display:flex><span>output <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>linear(embedded)  <span style=color:#75715e># (batch_size, vocab_size)</span>
</span></span></code></pre></div></blockquote></div></details><hr><details><summary><strong class=custom-details-title>⁉️ Word2Vec 如何优化训练效率？</strong></summary><div class=markdown-inner><h2><b>Word2Vec 如何优化训练效率？</b></h2><p>由于 softmax 操作的性质，上下文词可以是词表中的任意项，但是，在一个词典上（通常有几十万或数百万个单词）<strong>求和的梯度的计算成本是巨大的</strong>！为了降低计算复杂度，可以采用两种近似训练方法：负采样（Negative Sampling）和层序softmax（Hierarchical Softmax）。</p><ul><li><p><strong>负采样（Negative Sampling）</strong>：</p><ul><li><strong>核心思想</strong>：将复杂的多分类问题（预测所有词的概率）简化为二分类问题，用少量负样本近似全词汇的Softmax计算。</li><li><strong>正负样本构建</strong>：<ul><li>对每个正样本（中心词与真实上下文词对），随机采样 K 个负样本（非上下文词）。</li><li>例如，中心词 <code>“apple”</code> 的真实上下文词为 <code>“fruit”</code>，则负样本可能是随机选择的 <code>“car”</code>,<code>“book”</code> 等无关词。</li></ul></li><li><strong>目标函数</strong>：最大化正样本对的相似度，同时最小化负样本对的相似度。</li></ul></li><li><p><strong>层序softmax（Hierarchical Softmax）</strong>：</p><ul><li><strong>核心思想</strong>：通过二叉树（如霍夫曼树）编码词汇表，将全局Softmax分解为路径上的二分类概率乘积，减少计算量。</li><li><strong>霍夫曼树构建</strong>：按词频从高到低排列词汇，高频词靠近根节点，形成最短路径。每个内部节点含一个可训练的向量参数。</li></ul></div></li></ul></details><hr><details><summary><strong class=custom-details-title>⁉️ 解释 GloVe 的原理？</strong></summary><div class=markdown-inner><h2><b>解释 GloVe 的原理？</b></h2><p>GloVe（Global Vectors for Word Representation）是一种基于全局统计信息的词向量训练方法，它通过构造整个语料库的共现矩阵（co-occurrence matrix）并进行矩阵分解来学习词的向量表示，其核心思想是 <strong>通过捕捉词与词之间的全局共现关系来学习语义信息</strong>，而不是像 Word2Vec 那样依赖于局部上下文窗口的预测方法。
具体而言，GloVe 首先统计语料库中的词对共现次数，构建一个共现矩阵 X ，其中 X_{ij} 表示词 i 在词 j 附近出现的频率，并计算共现概率:</p><span>\[
P(j|i) = \frac{X_{ij}}{\sum_k X_{ik}}
\]</span><p>GloVe 的核心目标是学习一个词向量映射，使得向量之间的点积能够近似这个共现概率的对数：</p><span>\[
\mathbf{u}_j^\top \mathbf{v}_i + b_i + c_j = \log(X_{ij})
\]</span><ul><li>v_i, u_j 是词 i 和词 j 的向量表示，<strong>每个词都由两个向量组成，一个是中心词向量 ，一个是上下文词向量</strong></li></ul><p>GloVe 并不依赖传统的神经网络，它的学习过程 <strong>更接近矩阵分解（Matrix Factorization）的优化方法</strong>，而非 Word2Vec 这样的前馈神经网络（Feedforward Neural Network）。GloVe <strong>不依赖反向传播（Backpropagation）</strong>，而是直接最小化共现概率对数的加权平方误差，来学习词向量。</p><p>GloVe 的优势在于它直接建模了全局的词共现信息，使得词向量能够更好地捕捉语义相似性和类比关系，如 <code>“king - man + woman ≈ queen”</code>，但由于依赖于整个共现矩阵，计算和存储成本较高，因此适用于大规模离线训练，而不是在线学习任务。</p></div></details><hr><h3 id=transformer-中的-word-embedding><strong>Transformer 中的 Word Embedding</strong>
<a class=anchor href=#transformer-%e4%b8%ad%e7%9a%84-word-embedding>#</a></h3><details><summary><strong class=custom-details-title>⁉️ 如何理解 nn.Embedding？</strong></summary><div class=markdown-inner><h2><b>如何理解 nn.Embedding？</b></h2><p><code>nn.Embedding</code> 是 PyTorch 中用于实现词嵌入（Word Embedding）的一个非常核心的类。它的作用是：<strong>把一个词的整数编码（index）映射成一个稠密的向量（通常是高维的），这个向量是可以被训练学习的参数</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>torch<span style=color:#f92672>.</span>nn<span style=color:#f92672>.</span>Embedding(num_embeddings, embedding_dim)
</span></span></code></pre></div><ul><li><code>num_embeddings</code>: 词表的大小，也就是词的数量（每个词用一个整数表示，类似于 token id）。</li><li><code>embedding_dim</code>: 每个词要被映射成的向量维度（比如 300 或 768）。</li></ul><blockquote class="book-hint warning"><p><strong>Note:</strong> 可以把 nn.Embedding 看成一个 <strong>查找表（lookup table）</strong>：</p><ul><li>它其实就是一个 <code>num_embeddings × embedding_dim</code> 的权重矩阵 W。</li><li>输入的 token id 会被用作行索引，从 W 中取出对应的向量。</li></ul><p>比如，<code>W[0]</code> 就是 token id 为 0 的词的嵌入向量。这些向量是 <strong>可训练的参数</strong>，会在训练过程中通过反向传播自动学习优化。</p></blockquote><p><strong>用 one-hot 表示词再乘上一个线性层，其实就相当于 embedding</strong>。但：</p><ul><li><p><code>one-hot</code> 是稀疏向量，效率低。</p></li><li><p><code>nn.Embedding</code> 是直接用查表的方法，计算效率高，存储也少。</p></div></li></ul></details><hr><details><summary><strong class=custom-details-title>⁉️ 如何理解 Transformer中 nn.Embedding 和注意力层的关系？</strong></summary><div class=markdown-inner><h2><b>如何理解 Transformer中 nn.Embedding 和注意力层的关系？</b></h2><p><code>nn.Embedding</code> 的输入是 离散的 token index（整数），输出则是向量表示（如 768 维）。<strong>他的本质作用是建立词的初始语义表示，像是给每个词一个「名片」或「初始特征」。</strong></p><blockquote class="book-hint warning"><p><strong>Note:</strong> nn.Embedding 学到的是每个 token 的 <strong>静态语义向量表示</strong>（全局语义空间，相同的词 embedding 总是一样的），使得词语在 embedding 空间中更好地反映其语义与上下文分布特征：语义相似的词向量会更接近，并为后续 self-attention 提供语义基础。<strong>如果 embedding 学不到词义，那 attention 就无从发挥</strong>。</p></blockquote><p><strong>注意力机制并不是对单词进行「嵌入」，而是在已有的表示（embedding）上进一步挖掘</strong>：它学习当前 token 和其它 token 的相关性，并据此融合其它 token 的信息。对于某个词，Attention 通过融合其它词的信息，动态改变它的表示，关注“这次和谁有关”也就是说，Attention 模块输入的是 embedding（或者中间层表示），输出的是融合上下文信息后的表示。<strong>Attention 像是让这些词「互相交谈」，决定哪些词对我更重要，然后融合彼此的特征。</strong></p><p>总结来说，<code>nn.Embedding</code> 是每个词的静态语义初始向量，Attention 层是让词与词交互后产生的上下文相关向量。</p><blockquote class="book-hint warning"><p><strong>Q:</strong> <strong>如果把 nn.Embedding 当成一个固定（不可学习）的映射层，只是把 token index 投影到某个高维空间，Attention 机制是否还能正常工作？是否会受到限制？</strong></p><p><strong>A:</strong> 可以工作，但效果会显著受限，尤其是在表达复杂语义、上下文理解、泛化能力方面。attention 接收的输入质量差，导致它要用更多层去补救，甚至学不到真正任务相关的信息。</p><p>很多论文都做过类似 ablation（消融）实验。一般发现：</p><ul><li>在简单任务上（如文本分类）：性能下降 5～10%</li><li>在复杂生成任务（如机器翻译、对话、语言建模）：性能下降巨大，有时甚至无法训练收敛</li></ul></blockquote></div></details><hr><details><summary><strong class=custom-details-title>⁉️ 在实际项目中，Vector Database 使用的 Embedding 一般是哪一种类型？</strong></summary><div class=markdown-inner><h2><b>在实际项目中，Vector Database 使用的 Embedding 一般是哪一种类型？</b></h2><p>在使用类似这样的嵌入时：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>OpenAIEmbeddings(model<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;text-embedding-3-small&#34;</span>, openai_api_key<span style=color:#f92672>=</span>openai_api_key)
</span></span></code></pre></div><p>生成的 embedding 是 <strong>动态生成，静态存储的</strong>，即：</p><ul><li>嵌入向量在生成时是动态的（依赖输入文本的完整上下文），但一旦存入 VectorDB，便成为静态数据。后续检索时直接比较这些快照，不会重新计算。</li><li>尽管存储后是静态的，但动态嵌入在生成时已融入了上下文信息，相比静态嵌入质量更高。</li></ul><blockquote class="book-hint warning"><p><strong>Note:</strong> VectorDB 中存储的嵌入虽然本身是静态的，但它们在 <strong>生成时已经融入了原始文本的上下文信息</strong>。查询嵌入的动态生成确保了它与存储的静态嵌入在同一语义空间中进行相似度比较。<strong>即使存储的嵌入是静态的，查询嵌入的动态性仍能精准匹配到语义相关的文档。</strong></p><p><strong>e.g.</strong></p><ol><li><strong>存储阶段</strong><ul><li>文档1：&ldquo;苹果发布新款手机&rdquo; → 嵌入偏向 科技产品。</li><li>文档2：&ldquo;苹果的营养价值&rdquo; → 嵌入偏向 水果。</li></ul></li><li><strong>查询阶段</strong><ul><li>查询文本：&ldquo;苹果的最新科技产品&rdquo; → 动态生成的嵌入靠近文档1的语义。</li><li>检索结果：文档1会被优先召回，因为查询嵌入动态捕捉了“科技产品”的上下文，而非孤立词“苹果”。</li></ul></li></ol></blockquote></div></details><hr><details><summary><strong class=custom-details-title>⁉️ 在实际项目中，如何选择不同的嵌入方法（Embedding Methods）？</strong></summary><div class=markdown-inner><h2><b>在实际项目中，如何选择不同的嵌入方法（Embedding Methods）？</b></h2><ol><li><strong>任务类型与语义需求</strong>：</li></ol><ul><li><strong>基础语义任务（如文本分类、简单相似度计算）</strong>：<ul><li>静态嵌入：Word2Vec、GloVe、FastText。<ul><li>优点：轻量高效，适合低资源场景。</li><li>示例：新闻分类任务中，预训练的 Word2Vec 向量足以捕捉主题关键词的语义。</li></ul></li></ul></li><li><strong>复杂语义任务（如问答、指代消解、多义词理解）</strong>：<ul><li>上下文嵌入：BERT、RoBERTa、XLNet。<ul><li>优点：动态生成上下文相关向量，解决一词多义。</li><li>示例：在医疗问答系统中，BERT可区分“Apple”指公司还是水果。</li></ul></li></ul></li></ul><ol start=2><li><strong>数据量与领域适配</strong>：</li></ol><ul><li><p><strong>小数据场景</strong>：</p><ul><li><strong>预训练静态嵌入 + 微调</strong>：使用公开预训练的 Word2Vec/GloVe，结合任务数据微调。</li><li><strong>轻量上下文模型</strong>：ALBERT或TinyBERT，降低训练成本。</li></ul></li><li><p><strong>大数据场景</strong>：</p><ul><li><strong>从头训练上下文模型</strong>：基于领域数据训练BERT或GPT，捕捉领域专属语义。</li><li><strong>领域适配</strong>：在金融/法律等领域，使用领域语料继续预训练（Domain-Adaptive Pretraining）。</li></ul></div></li></ul></details><hr></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#分词tokenization><strong>分词（Tokenization）</strong></a><ul><li><a href=#分词的基本概念><strong>分词的基本概念</strong></a></li><li><a href=#分词方法bpe-wordpiece-sentencepiece><strong>分词方法（BPE, WordPiece, SentencePiece）</strong></a></li></ul></li><li><a href=#词嵌入word-embeddings><strong>词嵌入（Word Embeddings）</strong></a><ul><li><a href=#词嵌入的基本概念><strong>词嵌入的基本概念</strong></a></li><li><a href=#静态词向量word2vecskip-gramcbowglove><strong>静态词向量（Word2Vec，Skip-gram，CBOW，GloVe）</strong></a></li><li><a href=#transformer-中的-word-embedding><strong>Transformer 中的 Word Embedding</strong></a></li></ul></li></ul></nav></div></aside></main></body></html>