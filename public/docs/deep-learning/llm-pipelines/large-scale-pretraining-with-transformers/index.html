<!doctype html><html lang=en-us dir=ltr><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  基于Transformer的大规模预训练（Large-Scale Pretraining with Transformers）
  #

在传统任务（如图像分类、机器翻译）中，模型通常通过特定任务数据集从头训练（trained from scratch），成为专精单一任务的“专家”。例如，用英法双语对训练的Transformer模型仅能完成英译法任务，且对数据分布的微小变化敏感（易受分布偏移影响）。为提高模型泛化能力（generalization）并实现多任务处理（multitasking），大规模预训练（large-scale pretraining）逐渐成为主流。
Transformer的 可扩展性（scalability） 是其核心优势：随着模型参数（parameters）、训练数据量（training tokens）和计算资源（compute）的增加，性能按幂律关系显著提升。这一特性在视觉领域同样成立——更大规模的视觉Transformer（Vision Transformer, ViT）在更多数据训练下表现更优。
根据任务需求，Transformer可配置为三种模式：

仅编码器（Encoder-only）：适用于文本分类、命名实体识别等任务（如BERT）；
编码器-解码器（Encoder-Decoder）：用于序列到序列任务（如机器翻译，原始Transformer设计）；
仅解码器（Decoder-only）：专注于生成任务（如GPT系列），通过自回归（Autoregressive）方式逐个生成token。

预训练阶段常采用自监督学习（Self-Supervised Learning，如掩码语言建模MLM或下一词预测），通过海量数据学习通用表征，再通过微调（Fine-tuning）适配下游任务。


  Encoder-Only（BERT）
  #

仅编码器架构的Transformer（如BERT、Vision Transformer）仅保留编码器层，通过多层 自注意力（Self-Attention）和前馈网络（FFN） 提取输入序列的全局特征。所有输入token（如文本词或图像块）通过自注意力相互关联，最终输出与输入等长的表示向量。

典型应用场景：文本分类（如情感分析）、命名实体识别（NER）、图像分类（ViT）等。
输出处理：通常取序列开头的特殊标记 <cls> 的表示向量作为全局特征，再投影到任务标签（如分类层）。


Note： Encoder-Only 模型的核心特点就是 专注于理解（NLU, Natural Language Understanding），而且它的输出完全基于输入，不会额外生成新的内容。他们具有双向自注意力（Bidirectional Attention），可以同时建模左右上下文信息。因为不包含 Decoder，所以 不能生成文本。Encoder-Only 模型适用于以下任务：

✅ 文本分类（Text Classification）：垃圾邮件检测、情感分析、新闻分类
✅ 文本匹配（Text Matching）：文本相似度计算，如搜索引擎中的相关性排序
✅ 问答系统（QA）：如 SQuAD 任务，提取答案
✅ 信息检索（IR）：如 Google 搜索的 Query-Document 相关性计算




  BERT 的预训练与微调机制
  #

BERT 是 Google 在 2018 年提出的 NLP 预训练模型，全称 Bidirectional Encoder Representations from Transformers，它基于 Transformer 的 Encoder 结构，可以 双向建模上下文信息，用于多种 NLP 任务。BERT 只包含 Transformer 的 Encoder 部分，即："><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="http://localhost:1313/docs/deep-learning/llm-pipelines/large-scale-pretraining-with-transformers/"><meta property="og:site_name" content="Followblindly"><meta property="og:title" content="Large-Scale Pretraining with Transformers"><meta property="og:description" content="基于Transformer的大规模预训练（Large-Scale Pretraining with Transformers） # 在传统任务（如图像分类、机器翻译）中，模型通常通过特定任务数据集从头训练（trained from scratch），成为专精单一任务的“专家”。例如，用英法双语对训练的Transformer模型仅能完成英译法任务，且对数据分布的微小变化敏感（易受分布偏移影响）。为提高模型泛化能力（generalization）并实现多任务处理（multitasking），大规模预训练（large-scale pretraining）逐渐成为主流。
Transformer的 可扩展性（scalability） 是其核心优势：随着模型参数（parameters）、训练数据量（training tokens）和计算资源（compute）的增加，性能按幂律关系显著提升。这一特性在视觉领域同样成立——更大规模的视觉Transformer（Vision Transformer, ViT）在更多数据训练下表现更优。
根据任务需求，Transformer可配置为三种模式：
仅编码器（Encoder-only）：适用于文本分类、命名实体识别等任务（如BERT）； 编码器-解码器（Encoder-Decoder）：用于序列到序列任务（如机器翻译，原始Transformer设计）； 仅解码器（Decoder-only）：专注于生成任务（如GPT系列），通过自回归（Autoregressive）方式逐个生成token。 预训练阶段常采用自监督学习（Self-Supervised Learning，如掩码语言建模MLM或下一词预测），通过海量数据学习通用表征，再通过微调（Fine-tuning）适配下游任务。
Encoder-Only（BERT） # 仅编码器架构的Transformer（如BERT、Vision Transformer）仅保留编码器层，通过多层 自注意力（Self-Attention）和前馈网络（FFN） 提取输入序列的全局特征。所有输入token（如文本词或图像块）通过自注意力相互关联，最终输出与输入等长的表示向量。
典型应用场景：文本分类（如情感分析）、命名实体识别（NER）、图像分类（ViT）等。 输出处理：通常取序列开头的特殊标记 <cls> 的表示向量作为全局特征，再投影到任务标签（如分类层）。 Note： Encoder-Only 模型的核心特点就是 专注于理解（NLU, Natural Language Understanding），而且它的输出完全基于输入，不会额外生成新的内容。他们具有双向自注意力（Bidirectional Attention），可以同时建模左右上下文信息。因为不包含 Decoder，所以 不能生成文本。Encoder-Only 模型适用于以下任务：
✅ 文本分类（Text Classification）：垃圾邮件检测、情感分析、新闻分类 ✅ 文本匹配（Text Matching）：文本相似度计算，如搜索引擎中的相关性排序 ✅ 问答系统（QA）：如 SQuAD 任务，提取答案 ✅ 信息检索（IR）：如 Google 搜索的 Query-Document 相关性计算 BERT 的预训练与微调机制 # BERT 是 Google 在 2018 年提出的 NLP 预训练模型，全称 Bidirectional Encoder Representations from Transformers，它基于 Transformer 的 Encoder 结构，可以 双向建模上下文信息，用于多种 NLP 任务。BERT 只包含 Transformer 的 Encoder 部分，即："><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><title>Large-Scale Pretraining with Transformers | Followblindly</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=http://localhost:1313/docs/deep-learning/llm-pipelines/large-scale-pretraining-with-transformers/><link rel=stylesheet href=/book.min.bff4c6870ba26abd815329272c8df8231704f9ac54bee84c3ef1f649e394d14f.css integrity="sha256-v/TGhwuiar2BUyknLI34IxcE+axUvuhMPvH2SeOU0U8=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.14b6ef784dbbb87e4050b94d8cd713a1b1d5f84977c0a2738fcdcc6b6e8c5c89.js integrity="sha256-FLbveE27uH5AULlNjNcTobHV+El3wKJzj83Ma26MXIk=" crossorigin=anonymous></script><link rel=alternate type=application/rss+xml href=http://localhost:1313/docs/deep-learning/llm-pipelines/large-scale-pretraining-with-transformers/index.xml title=Followblindly></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/As.png alt=Logo class=book-icon><span>Followblindly</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><span>Python Basics</span><ul><li><a href=/docs/python-basics/python-fundamentals/>Python Fundamentals</a><ul></ul></li><li><input type=checkbox id=section-b0810fa42fa69050cb4968ec00fbf282 class=toggle>
<label for=section-b0810fa42fa69050cb4968ec00fbf282 class="flex justify-between"><a href=/docs/python-basics/leetcode/>Leetcode Notes</a></label><ul><li><a href=/docs/python-basics/leetcode/practice-history/>Practice History</a><ul></ul></li></ul></li></ul></li><li class=book-section-flat><input type=checkbox id=section-7e28d5ac3e9843e0deb580be9504447e class=toggle>
<label for=section-7e28d5ac3e9843e0deb580be9504447e class="flex justify-between"><a role=button>Common Libraries</a></label><ul><li><a href=/docs/common-libraries/numpy/>NumPy</a><ul></ul></li><li><a href=/docs/common-libraries/pandas/>Pandas</a><ul></ul></li><li><a href=/docs/common-libraries/pytorch/>PyTorch</a><ul></ul></li></ul></li><li class=book-section-flat><span>Machine Learning</span><ul><li><a href=/docs/machine-learning/machine-learning-basics/>Machine Learning Basics</a><ul></ul></li><li><a href=/docs/machine-learning/data-preprocessing/>Data Preprocessing</a><ul></ul></li><li><input type=checkbox id=section-89d4dd5d95507b817cf74368af5982ba class=toggle>
<label for=section-89d4dd5d95507b817cf74368af5982ba class="flex justify-between"><a href=/docs/machine-learning/supervised-learning/>Supervised Learning</a></label><ul><li><a href=/docs/machine-learning/supervised-learning/linear-regression/>Linear Regression</a><ul></ul></li><li><a href=/docs/machine-learning/supervised-learning/logistic-regression/>Logistic Regression</a><ul></ul></li></ul></li><li><input type=checkbox id=section-452d9bf73a55e6b3d947afcc89364ff4 class=toggle>
<label for=section-452d9bf73a55e6b3d947afcc89364ff4 class="flex justify-between"><a href=/docs/machine-learning/unsupervised-learning/>Unsupervised Learning</a></label><ul></ul></li><li><a href=/docs/machine-learning/regularization/>Regularization</a><ul></ul></li><li><a href=/docs/machine-learning/optimization/>Optimization</a><ul></ul></li><li><a href=/docs/machine-learning/computational-performance/>Computational Performance</a><ul></ul></li></ul></li><li class=book-section-flat><span>Deep Learning</span><ul><li><a href=/docs/deep-learning/perceptrons-and-neural-network/>Perceptrons and Neural Network</a><ul></ul></li><li><input type=checkbox id=section-d0dd931d60033c220ecd4cd60b7c9170 class=toggle>
<label for=section-d0dd931d60033c220ecd4cd60b7c9170 class="flex justify-between"><a href=/docs/deep-learning/convolutional-neural-networks/>Convolutional Neural Networks</a></label><ul><li><a href=/docs/deep-learning/convolutional-neural-networks/modern-convolutional-neural-networks/>Modern Convolutional Neural Networks</a><ul></ul></li></ul></li><li><input type=checkbox id=section-a3019bfa8037cc33ed6405d1589b6219 class=toggle>
<label for=section-a3019bfa8037cc33ed6405d1589b6219 class="flex justify-between"><a href=/docs/deep-learning/recurrent-neural-networks/>Recurrent Neural Networks</a></label><ul><li><a href=/docs/deep-learning/recurrent-neural-networks/modern-recurrent-neural-networks/>Modern Recurrent Neural Networks</a><ul></ul></li></ul></li><li><input type=checkbox id=section-0a43584c16258b228ae9aa8d70efc320 class=toggle>
<label for=section-0a43584c16258b228ae9aa8d70efc320 class="flex justify-between"><a href=/docs/deep-learning/attention-and-transformers/>Attention and Transformers</a></label><ul><li><a href=/docs/deep-learning/attention-and-transformers/tokenization-and-word-embeddings/>Tokenization and Word Embeddings</a><ul></ul></li><li><a href=/docs/deep-learning/attention-and-transformers/transformer-architecture/>Transformer Architecture</a><ul></ul></li><li><a href=/docs/deep-learning/attention-and-transformers/modern-large-language-models/>Modern LLMs and Pre-Training</a><ul></ul></li><li><a href=/docs/deep-learning/attention-and-transformers/post-training-large-language-models/>Post-training LLMs</a><ul></ul></li><li><a href=/docs/deep-learning/attention-and-transformers/multimodal-large-language-models/>Multimodal Large Language Models</a><ul></ul></li></ul></li><li><input type=checkbox id=section-92e8358c45c96009753cf4227e9daea8 class=toggle checked>
<label for=section-92e8358c45c96009753cf4227e9daea8 class="flex justify-between"><a href=/docs/deep-learning/llm-pipelines/>LLM Pipelines</a></label><ul><li><a href=/docs/deep-learning/llm-pipelines/llm-hardware-and-model-size/>LLM Hardware and Model Size</a><ul></ul></li><li><a href=/docs/deep-learning/llm-pipelines/large-scale-pretraining-with-transformers/ class=active>Large-Scale Pretraining with Transformers</a><ul></ul></li><li><a href=/docs/deep-learning/llm-pipelines/llm-inference-and-deployment/>LLM Inference and Deployment</a><ul></ul></li></ul></li></ul></li><li class=book-section-flat><input type=checkbox id=section-8b0266d7d6ac3da61ec6acf4e97681ca class=toggle>
<label for=section-8b0266d7d6ac3da61ec6acf4e97681ca class="flex justify-between"><a role=button>Others</a></label><ul><li><a href=/docs/others/interview-preparation-guide/>Interview Preparation Guide</a><ul></ul></li></ul></li></ul><ul><li><a href=/posts/>Blog</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Large-Scale Pretraining with Transformers</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><link rel=stylesheet href=/css/prism-one-dark.css><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#encoder-onlybert><strong>Encoder-Only（BERT）</strong></a><ul><li><a href=#bert-的预训练与微调机制><strong>BERT 的预训练与微调机制</strong></a></li></ul></li><li><a href=#encoder-decodert5><strong>Encoder-Decoder（T5）</strong></a><ul><li><a href=#t5-的预训练与微调机制><strong>T5 的预训练与微调机制</strong></a></li></ul></li><li><a href=#decoder-onlygpt><strong>Decoder-Only（GPT）</strong></a><ul><li><a href=#gpt如何区分不同任务如问答-vs-文本生成><strong>GPT如何区分不同任务（如问答 vs 文本生成）？</strong></a></li></ul></li><li><a href=#基础预训练模型><strong>基础预训练模型</strong></a><ul><li><a href=#bertmasked-language-model-next-sentence-prediction><strong>BERT（Masked Language Model, Next Sentence Prediction）</strong></a></li><li><a href=#t5bartseq2seq-预训练模型><strong>T5、BART（Seq2Seq 预训练模型）</strong></a></li><li><a href=#gpt-2--gpt-3autoregressive-language-model><strong>GPT-2 / GPT-3（Autoregressive Language Model）</strong></a></li></ul></li><li><a href=#预训练细节><strong>预训练细节</strong></a><ul><li><a href=#预训练定义><strong>预训练定义</strong></a></li><li><a href=#预训练数据><strong>预训练数据</strong></a></li><li><a href=#预训练流程><strong>预训练流程</strong></a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=基于transformer的大规模预训练large-scale-pretraining-with-transformers><strong>基于Transformer的大规模预训练（Large-Scale Pretraining with Transformers）</strong>
<a class=anchor href=#%e5%9f%ba%e4%ba%8etransformer%e7%9a%84%e5%a4%a7%e8%a7%84%e6%a8%a1%e9%a2%84%e8%ae%ad%e7%bb%83large-scale-pretraining-with-transformers>#</a></h1><p>在传统任务（如图像分类、机器翻译）中，模型通常通过特定任务数据集从头训练（trained from scratch），成为专精单一任务的“专家”。例如，用英法双语对训练的Transformer模型仅能完成英译法任务，且对数据分布的微小变化敏感（易受分布偏移影响）。为提高模型泛化能力（generalization）并实现多任务处理（multitasking），大规模预训练（large-scale pretraining）逐渐成为主流。</p><p>Transformer的 <strong>可扩展性（scalability）</strong> 是其核心优势：<strong>随着模型参数（parameters）、训练数据量（training tokens）和计算资源（compute）的增加，性能按幂律关系显著提升</strong>。这一特性在视觉领域同样成立——更大规模的视觉Transformer（Vision Transformer, ViT）在更多数据训练下表现更优。</p><p>根据任务需求，Transformer可配置为三种模式：</p><ul><li><strong>仅编码器（Encoder-only）</strong>：适用于文本分类、命名实体识别等任务（如BERT）；</li><li><strong>编码器-解码器（Encoder-Decoder）</strong>：用于序列到序列任务（如机器翻译，原始Transformer设计）；</li><li><strong>仅解码器（Decoder-only）</strong>：专注于生成任务（如GPT系列），通过自回归（Autoregressive）方式逐个生成token。</li></ul><p>预训练阶段常采用自监督学习（Self-Supervised Learning，如掩码语言建模MLM或下一词预测），通过海量数据学习通用表征，再通过微调（Fine-tuning）适配下游任务。</p><hr><h2 id=encoder-onlybert><strong>Encoder-Only（BERT）</strong>
<a class=anchor href=#encoder-onlybert>#</a></h2><p>仅编码器架构的Transformer（如BERT、Vision Transformer）仅保留编码器层，通过多层 <strong>自注意力（Self-Attention）和前馈网络（FFN）</strong> 提取输入序列的全局特征。所有输入token（如文本词或图像块）通过自注意力相互关联，最终输出与输入等长的表示向量。</p><ul><li><strong>典型应用场景</strong>：文本分类（如情感分析）、命名实体识别（NER）、图像分类（ViT）等。</li><li><strong>输出处理</strong>：通常取序列开头的特殊标记 <code>&lt;cls></code> 的表示向量作为全局特征，再投影到任务标签（如分类层）。</li></ul><blockquote class="book-hint warning"><p><strong>Note：</strong> Encoder-Only 模型的核心特点就是 <strong>专注于理解</strong>（NLU, Natural Language Understanding），<strong>而且它的输出完全基于输入，不会额外生成新的内容</strong>。他们具有双向自注意力（Bidirectional Attention），可以同时建模左右上下文信息。因为不包含 Decoder，所以 <strong>不能生成文本</strong>。Encoder-Only 模型适用于以下任务：</p><ul><li>✅ <strong>文本分类（Text Classification）</strong>：垃圾邮件检测、情感分析、新闻分类</li><li>✅ <strong>文本匹配（Text Matching）</strong>：文本相似度计算，如搜索引擎中的相关性排序</li><li>✅ <strong>问答系统（QA）</strong>：如 SQuAD 任务，提取答案</li><li>✅ <strong>信息检索（IR）</strong>：如 Google 搜索的 Query-Document 相关性计算</li></ul></blockquote><hr><h3 id=bert-的预训练与微调机制><strong>BERT 的预训练与微调机制</strong>
<a class=anchor href=#bert-%e7%9a%84%e9%a2%84%e8%ae%ad%e7%bb%83%e4%b8%8e%e5%be%ae%e8%b0%83%e6%9c%ba%e5%88%b6>#</a></h3><p>BERT 是 Google 在 2018 年提出的 NLP 预训练模型，全称 <strong>Bidirectional Encoder Representations from Transformers</strong>，它基于 Transformer 的 Encoder 结构，可以 双向建模上下文信息，用于多种 NLP 任务。BERT 只包含 Transformer 的 Encoder 部分，即：</p><ul><li>输入是整个句子（token embedding + positional encoding）</li><li>多个 Encoder 层进行双向自注意力计算</li><li><strong>输出是整个句子的上下文表示</strong></li></ul><p>它没有 Transformer Decoder，BERT 主要用于理解任务，而非生成任务，所以是 Encoder-only 结构。</p><ol><li><strong>预训练（Pretraining）</strong></li></ol><div align=center><img src=/images/bert-encoder-only.svg width=500px/></div><ul><li><strong>任务设计</strong>：采用<strong>掩码语言建模（Masked Language Modeling, MLM）</strong>，随机遮盖输入文本中的部分token（如将“I love this red car”中的“love”替换为 <code>&lt;mask></code>）。在训练时，BERT 随机掩盖（Mask）输入文本的 15% token，然后让模型预测被遮挡的 token。</li></ul><blockquote class="book-hint warning"><p><strong>Note：</strong> BERT 的 <strong>Masked Language Modeling</strong> 本质上就是在做“完形填空”：预训练时，先将一部分词随机地盖住，经过模型的拟合，<strong>如果能够很好地预测那些盖住的词，模型就学到了文本的内在逻辑</strong>。这部分的主要作用是让模型 <strong>学到词汇和语法规则，提高语言理解能力</strong>。</p><p>除了“完形填空”，BERT还需要做 <strong>Next Sentence Prediction</strong> 任务：预测句子B是否为句子A的下一句。Next Sentence Prediction有点像英语考试中的“段落排序”题，只不过简化到只考虑两句话。<strong>如果模型无法正确地基于当前句子预测 Next Sentence，而是生硬地把两个不相关的句子拼到一起，两个句子在语义上是毫不相关的，说明模型没有读懂文本背后的意思。</strong> 这部分的主要作用是让模型 <strong>学习句子级别的语义关系</strong>。</p></blockquote><ul><li><strong>双向上下文建模</strong>：因编码器自注意力无方向限制，预测遮盖token时可利用前后文信息（如“red car”帮助预测“love”）。不像传统的 LSTM 只能从左到右或右到左。</li><li><strong>数据优势</strong>：无需人工标注，可基于书籍、维基百科等大规模文本自监督学习。</li></ul><blockquote class="book-hint warning"><p><strong>Note：</strong> <strong>自监督学习（Self-Supervised Learning, SSL）</strong> 是一种机器学习范式，它不依赖人工标注的数据，而是让模型自己从数据的结构或属性中创造监督信号。他的核心在于 <strong>“数据自己监督自己”，也就是说，模型用数据的一部分去预测另一部分</strong>，从而学到有意义的表示。</p></blockquote><ol start=2><li><p><strong>微调（Fine-Tuning）</strong></p><p>预训练的 BERT 模型可以通过微调（Fine-Tuning）适应下游的编码任务，包括单文本或文本对的处理。在微调过程中，<strong>可以在 BERT 之上添加参数随机初始化的额外层，这些新层和 BERT 的预训练参数将共同更新，以适应下游任务的训练数据</strong>。</p><p>以情感分析为例，微调过程如下图所示：预训练的 BERT 作为 Transformer 编码器，输入一个文本序列，并将其 <code>[CLS]</code> 表示（即输入的全局表示）传递给一个额外的全连接层，以预测情感倾向。在微调期间，通过基于梯度的算法最小化预测结果与情感分析数据标签之间的交叉熵损失。此时，额外的全连接层从头开始训练，而 BERT 的预训练参数也会更新。</p><div align=center><img src=/images/bert-finetune-classification.svg width=300px/></div><p>BERT 不仅适用于情感分析。通过对 2,500 亿个训练标记（tokens）进行预训练，拥有 3.5 亿参数的 BERT 学习到了通用的语言表示，这使其在单文本分类、文本对分类或回归、文本标注以及问答等自然语言处理任务上达到了新的水平。</p></li></ol><hr><h2 id=encoder-decodert5><strong>Encoder-Decoder（T5）</strong>
<a class=anchor href=#encoder-decodert5>#</a></h2><p>Transformer 中的 Encoder-Decoder 架构最早是为机器翻译（Machine Translation）提出的。在这种架构中，Encoder 将输入序列转换成相应数量的输出表示，而 Decoder 根据 Encoder 的输出和先前的 Decoder 输出，逐步自回归地生成目标序列（token-by-token）。</p><p>为了在机器翻译数据之外进行预训练，BART（Lewis et al., 2019）和T5（Raffel et al., 2020）是两个被提出的编码器-解码器Transformer模型，这两个模型在大规模文本语料库上进行了预训练。BART强调通过对输入进行加噪处理（如masking、删除、排列和旋转）来预训练，而T5则通过多任务学习的方式统一目标，并通过全面的消融研究（ablation studies）来进行验证。这些方法使得<strong>Transformer 的编码器-解码器架构不仅限于机器翻译，还能够扩展到其他文本生成任务</strong>。</p><blockquote class="book-hint warning"><p><strong>Note：</strong> Encoder-Decoder模型同时具备了 <strong>理解（Encoder）和生成（Decoder）</strong> 的能力，因此它能够处理复杂的任务，如机器翻译、文本摘要、图像描述等。这类模型既能够通过 Encoder 理解输入，又能通过 Decoder 生成输出。Encoder–Decoder模型的好处有：</p><ol><li><strong>生成能力</strong>：Encoder–Decoder 架构能够生成任意长度的输出序列，而不是像Encoder-only模型那样只能生成固定长度的表示。它允许通过解码器（Decoder）逐步生成目标序列，非常适合像机器翻译和文本摘要等生成任务。</li><li><strong>灵活的输入和输出</strong>：Encoder-only 模型和 Decoder-only 模型通常输入和输出的长度是固定的，而 Encoder–Decoder 模型能够灵活地处理不同长度的输入和输出。Decoder 可以根据输入序列生成任意长度的目标序列，从而适应更复杂的任务。</li><li><strong>跨任务的预训练能力</strong>：Encoder–Decoder模型可以通过多任务学习提升模型的泛化能力。比如，T5模型通过将不同任务（如文本分类、文本生成等）统一为一个多任务预训练框架，从而增强了模型对不同任务的处理能力。</li></ol></blockquote><hr><h3 id=t5-的预训练与微调机制><strong>T5 的预训练与微调机制</strong>
<a class=anchor href=#t5-%e7%9a%84%e9%a2%84%e8%ae%ad%e7%bb%83%e4%b8%8e%e5%be%ae%e8%b0%83%e6%9c%ba%e5%88%b6>#</a></h3><p><strong>T5（Text-to-Text Transfer Transformer）</strong> 是一个预训练的 Transformer 编码器-解码器模型，它将许多任务统一为同一个文本到文本的问题。在T5的任务设置中，编码器的输入包括一个任务描述（例如：“Summarize”表示总结任务），后跟任务的输入（例如文章的标记序列）。解码器则预测任务的输出（例如输入文章的摘要）。T5的训练目标是基于输入文本生成目标文本。</p><ol><li><p><strong>预训练（Pretraining）</strong>
为了进行预训练，T5通过预测连续的标记范围来进行训练。具体来说，<strong>文本中的一些标记会被随机替换成特殊标记</strong>，每一组连续的标记被替换成相同的特殊标记。例如，在一个句子中，“I”, “love”, “this”, “red”, “car”中，“love”被替换为一个特殊标记“”，“red”和“car”也被替换为另一个特殊标记“”。这样，输入序列就变成了“I”, “<code>&lt;X></code>”, “this”, “<code>&lt;Y></code>”，而目标序列是“<code>&lt;X></code>”, “love”, “<code>&lt;Y></code>”, “red”, “car”, “<code>&lt;Z></code>”，其中“<code>&lt;Z></code>”是表示结束的特殊标记。此任务的目标是通过这种方式 <strong>恢复被替换的文本，从而在预训练中学习到文本的结构和语言模式</strong>。</p><div align=center><img src=/images/t5-encoder-decoder.svg width=500px/></div><p>在T5的Transformer结构中，编码器的自注意力（Self-Attention）机制使得所有输入标记相互注意，而编码器-解码器之间的交叉注意力（Cross-Attention）使得每个目标标记能够关注所有输入标记。解码器的自注意力则具有因果性（Causal Attention）模式，以确保在预测时不会关注到未来的标记。</p><p>T5的预训练使用了1000亿个来自C4（Colossal Clean Crawled Corpus）数据集的标记，该数据集包含来自网络的清洁英语文本。T5的预训练目标是通过这种方式预测连续的标记范围（也称为 <strong>重建损坏的文本</strong>），帮助模型学习如何生成与输入文本相关的输出文本。</p><p>这种结构的核心优势在于，它为各种自然语言处理任务提供了一个统一的框架，无论是文本分类、摘要生成，还是问答任务，都可以通过这种“文本到文本”的方式进行处理。</p></li><li><p><strong>微调（Fine-Tuning）</strong></p><p>T5（Text-to-Text Transfer Transformer）模型与BERT相似，也需要通过在特定任务的数据上进行微调（fine-tuning）来完成下游任务。与BERT的微调有所不同，T5的主要特点包括：<strong>（1）T5的输入包含任务描述；（2）T5通过其 Transformer 解码器可以生成任意长度的序列；（3）T5不需要额外的层来进行微调。</strong></p><p>以文本摘要任务为例，T5的微调过程如下图所示。具体来说，任务描述标记（如“Summarize”）与文章的标记一起输入到Transformer编码器，用以预测摘要。这样，T5能够理解不同任务，并通过任务描述来指导模型进行相应的生成任务。</p><div align=center><img src=/images/t5-finetune-summarization.svg width=400px/></div></li></ol><hr><h2 id=decoder-onlygpt><strong>Decoder-Only（GPT）</strong>
<a class=anchor href=#decoder-onlygpt>#</a></h2><p>在 decoder-only 结构中，模型只包含解码器部分，这使得它主要专注于 <strong>生成任务</strong>。与 encoder-decoder 结构不同，decoder-only Transformer 可以直接根据输入的文本生成输出，因此在许多自然语言处理任务中表现出色，尤其是在大规模的预训练任务中。</p><blockquote class="book-hint warning"><p><strong>Note：</strong> <strong>Encoder-Decoder 和 Decoder-only 的区别</strong>：Decoder-only（如GPT）仅保留解码器，通过自回归生成（逐词预测）完成任务。适用任务主要为生成类任务（文本续写、对话、代码生成）。Encoder-Decoder（如原始Transformer、T5）分离编码器（理解输入）与解码器（生成输出），通过交叉注意力传递信息。适用任务主要为需严格分离输入理解与输出生成的任务（翻译、摘要、问答）。</p><p>Decoder-only模型通过 <strong>上下文学习（In-Context Learning）</strong> 将任务隐式编码到输入中（如添加“Translate English to French:”前缀），利用生成能力模拟翻译，完成和 Encoder-Decoder 一样的工作。但是 Encoder-Decoder在以下场景更具优势：</p><ol><li><strong>输入与输出解耦的复杂任务（如翻译）</strong>：Encoder-Decoder 模型的编码器可先提取完整语义，解码器再逐词生成，避免生成过程中的语义偏差，准确性更高。而Decoder-only模型（如GPT-3）需通过Prompt（如“Translate English to French: &mldr;”）隐式对齐输入输出，<strong>易受提示词设计影响</strong>。</li><li><strong>长文本处理效率</strong>：Encoder-Decoder：编码器一次性压缩输入为固定长度表示，解码生成时无需重复处理长输入（节省计算资源）。Decoder-only：<strong>生成每个词时需重新处理整个输入序列</strong>（如输入1000词的文档），导致计算复杂度高。</li></ol><ul><li><strong>总结来说</strong><ul><li><strong>Decoder-only</strong>：适合开放域生成任务，依赖生成连贯性与上下文学习，但对输入-输出结构复杂的任务效率较低。</li><li><strong>Encoder-Decoder</strong>：在需严格分离理解与生成、处理长输入、多任务统一的场景中更优，尤其适合翻译、摘要等结构化任务。</li><li>类比：Decoder-only像“自由创作的作家”，Encoder-Decoder像“严谨的翻译官”——前者更灵活，后者更精准。</li></ul></li></ul></blockquote><div align=center><img src=/images/gpt-decoder-only.svg width=500px/></div><p>GPT（Generative Pre-trained Transformer）基于仅解码器架构（Decoder-only），移除原始Transformer的编码器和交叉注意力层，保留掩码自注意力（Masked Self-Attention）与前馈网络（FFN）。输入处理时，文本序列添加特殊标记 <code>&lt;bos></code>（序列开始）和 <code>&lt;eos></code>（序列结束），目标序列为输入右移一位。注意力限制方面，通过 <strong>因果掩码（Causal Mask）</strong> 强制每个token仅关注其左侧上下文。</p><p>Decoder-Only 模型移除了Encoder和交叉注意力层，仅保留自注意力层和前馈网络（FFN）。<strong>所有注意力均为自注意力</strong>：<span>
\(Q、K、V\)
</span>均来自同一输入序列（例如输入文本的前缀部分）。例如，输入“I love deep”，模型通过自注意力计算每个词与所有已输入词的关系，生成下一个词“learning”。</p><p>预训练任务是 <strong>自回归语言建模（Autoregressive LM）</strong>：最大化序列联合概率，损失函数为交叉熵（Cross-Entropy）：
<span>\[
\begin{equation}
\mathcal{L} = -\sum_{t=1}^{T} \log P(w_t | w_{1:t-1 })
\end{equation}
\]</span></p><ul><li><strong>输入输出</strong>：共享同一序列（如输入为"Translate English to French: &lsquo;hello&rsquo; →"，输出生成"bonjour"）。</li><li><strong>核心机制</strong>：GPT通过统计建模（而非“记忆”）学习语言规律。预训练时，模型并非记住所有可能的输入与输出组合，而是通过概率分布捕捉词与词之间的关联性。<ul><li>例如：输入“The capital of France is”，模型根据统计规律高概率生成“Paris”（而非“London”）。</li><li>对于罕见组合（如“The capital of France is made of”），模型可能生成符合语法但语义荒谬的结果（如“cheese”），反映其依赖训练数据的分布。</li></ul></li><li><strong>生成能力</strong>：模型通过自回归生成（逐词预测）产生连贯文本，但无法保证事实准确性（可能产生“幻觉”）。</li></ul><hr><h3 id=gpt如何区分不同任务如问答-vs-文本生成><strong>GPT如何区分不同任务（如问答 vs 文本生成）？</strong>
<a class=anchor href=#gpt%e5%a6%82%e4%bd%95%e5%8c%ba%e5%88%86%e4%b8%8d%e5%90%8c%e4%bb%bb%e5%8a%a1%e5%a6%82%e9%97%ae%e7%ad%94-vs-%e6%96%87%e6%9c%ac%e7%94%9f%e6%88%90>#</a></h3><p>GPT本身不具备显式任务识别模块，而是 <strong>通过输入格式（Prompt）的上下文模式隐式引导生成结果</strong>。所有任务均<strong>被转化为文本生成任务</strong>，其核心原理基于预训练阶段对海量文本模式的学习。</p><ol><li><p><strong>预训练数据的模式学习</strong>：在预训练阶段，GPT接触了包含多种任务格式的文本（如问答对、翻译示例、代码片段），通过自回归目标学习这些模式：</p><ul><li><p><strong>示例</strong>：</p><pre tabindex=0><code>## 问答类
Q: What is photosynthesis?  
A: Photosynthesis is the process by which plants convert sunlight into energy.  
</code></pre><pre tabindex=0><code>## 翻译类
Translate English to French: &#34;hello&#34; → &#34;bonjour&#34;  
</code></pre></li><li><p><strong>学习结果</strong>：模型统计性掌握不同任务对应的输入-输出格式规律（如“Q:”后通常接答案，“Translate”后接目标语言）。</p></li></ul></li><li><p><strong>训练数据的多样性是关键：</strong> GPT的预训练数据包含海量互联网文本（书籍、网页、代码等），天然涵盖多种任务模式：</p><ul><li><strong>问答对</strong>：论坛讨论、维基百科（如“Q: What is photosynthesis? A: &mldr;”）。</li><li><strong>翻译示例</strong>：多语言网页对照、教材例句（如“Hello → Bonjour”）。</li><li><strong>代码注释</strong>：GitHub代码库中的函数与注释（如“# 计算阶乘 → def factorial(n): &mldr;”）。</li><li><strong>对话记录</strong>：社交媒体对话（如“User: How are you? Bot: I’m fine.”）。</li></ul><p>模型通过自回归目标（预测下一词）<strong>隐式学习这些模式，而非显式标注任务类型</strong>。即模型在训练时并不是根据任务去显式的分类学习的，而是隐式的学习规律。</p></li><li><p><strong>生成过程的隐式任务引导</strong>：生成时，模型基于Prompt的上下文模式，激活预训练中学习到的对应任务生成策略</p></li></ol><div align=center><img src=/images/gpt-3-xshot.svg width=650px/></div><ol start=4><li><strong>上下文学习（In-Context Learning）</strong>：GPT通过<strong>少量示例（Few-shot）或纯指令（Zero-shot）</strong> 显式定义任务类型：<ul><li><strong>Few-shot示例：</strong><pre tabindex=0><code>Q: Capital of France? A: Paris  
Q: Capital of Japan? A: Tokyo  
Q: Capital of Brazil? A:  
</code></pre><ul><li>模型通过前两例学习“Q-A”模式，生成“Brasília”。</li></ul></li><li><strong>Zero-shot指令：</strong><pre tabindex=0><code>Please answer the following question:  
What is the boiling point of water?  
Answer:  
</code></pre><ul><li>模型根据指令词“Please answer”生成“100°C (212°F) at sea level”。</li></ul></li></ul></li><li><strong>若Prompt设计模糊，模型可能生成不符合预期的结果。</strong></li></ol><hr><h2 id=基础预训练模型><strong>基础预训练模型</strong>
<a class=anchor href=#%e5%9f%ba%e7%a1%80%e9%a2%84%e8%ae%ad%e7%bb%83%e6%a8%a1%e5%9e%8b>#</a></h2><h3 id=bertmasked-language-model-next-sentence-prediction><strong>BERT（Masked Language Model, Next Sentence Prediction）</strong>
<a class=anchor href=#bertmasked-language-model-next-sentence-prediction>#</a></h3><details><summary><strong class=custom-details-title>⁉️ BERT 的预训练目标有哪些？什么是 MLM 和 NSP？具体如何实现？</strong></summary><div class=markdown-inner><h2><b>BERT 的预训练目标有哪些？什么是 MLM 和 NSP？具体如何实现？</b></h2><p>BERT（Bidirectional Encoder Representations from Transformers）的预训练目标主要包括 <strong>Masked Language Modeling（MLM）</strong> 和 <strong>Next Sentence Prediction（NSP）</strong>。</p><p>在 MLM 任务 中，BERT <strong>随机遮盖（mask）</strong> 输入文本中的部分词汇（通常为 15%），并通过 Transformer Encoder 预测这些被遮盖的词。具体实现时，80% 的被遮盖词替换为 <code>[MASK]</code>，10% 保持不变，另 10% 替换为随机词，以增强模型的泛化能力。</p><p>NSP 任务 旨在学习句子级别的关系，BERT 通过给定的两个句子 <strong>判断它们是否为原始文本中的连续句（IsNext）或随机拼接的无关句（NotNext）</strong>。训练时，BERT 以 50% 的概率选择相邻句子作为正样本，另 50% 选择无关句子作为负样本，并通过 二分类损失函数（Binary Cross-Entropy Loss） 进行优化。<strong>MLM 使 BERT 能够学习上下文双向依赖关系，而 NSP 则有助于建模句子间的全局关系</strong>，这两个目标共同提升了 BERT 在 自然语言理解（Natural Language Understanding, NLU） 任务中的表现。</p><blockquote class="book-hint warning"><p><strong>Note：</strong> BERT 的 <strong>Masked Language Modeling</strong> 本质上就是在做“完形填空”：预训练时，先将一部分词随机地盖住，经过模型的拟合，<strong>如果能够很好地预测那些盖住的词，模型就学到了文本的内在逻辑</strong>。这部分的主要作用是让模型 <strong>学到词汇和语法规则，提高语言理解能力</strong>。</p><p>除了“完形填空”，BERT还需要做 <strong>Next Sentence Prediction</strong> 任务：预测句子B是否为句子A的下一句。Next Sentence Prediction有点像英语考试中的“段落排序”题，只不过简化到只考虑两句话。<strong>如果模型无法正确地基于当前句子预测 Next Sentence，而是生硬地把两个不相关的句子拼到一起，两个句子在语义上是毫不相关的，说明模型没有读懂文本背后的意思。</strong> 这部分的主要作用是让模型 <strong>学习句子级别的语义关系</strong>。</p></blockquote></div></details><details><summary><strong class=custom-details-title>⁉️ 为什么 BERT 的输入需要添加 [CLS] 和 [SEP] 特殊标记？</strong></summary><div class=markdown-inner><h2><b>为什么 BERT 的输入需要添加 [CLS] 和 [SEP] 特殊标记？</b></h2><p>BERT 的输入需要添加 <code>[CLS]</code> 和 <code>[SEP]</code> 特殊标记，主要是用来表示 Next Sentence Prediction（NSP） 任务的输入格式，并增强模型的表示能力。例如：</p><pre tabindex=0><code>[CLS] 句子A [SEP] 句子B [SEP]
</code></pre><ul><li><strong><code>[CLS]</code>（Classification Token）</strong>：BERT 在输入序列的开头始终添加 <code>[CLS]</code>，它的最终隐藏状态（Hidden State）可以作为整个序列的表示，特别 <strong>适用于分类任务</strong>（如情感分析、自然语言推理 NLI）。即使不是分类任务，BERT 仍然会计算 <code>[CLS]</code> 的表示，因此它始终是输入的一部分。</li><li><strong><code>[SEP]</code>（Separator Token）</strong>：BERT 采用双向 Transformer，因此需要区分单句和双句任务。在单句任务（如情感分析）中，输入序列结尾会加 <code>[SEP]</code>，而在双句任务（如问答 QA 或文本匹配），<code>[SEP]</code> 用于分隔两个句子，帮助 BERT 处理跨句子的关系建模。</li></ul><p>在 微调阶段（Fine-Tuning），不同任务对 <code>[CLS]</code> 和 <code>[SEP]</code> 的使用方式略有不同。例如：</p><ul><li><strong>文本分类（如情感分析）</strong>：<code>[CLS]</code> 的最终表示输入到 Softmax 层进行分类。</li><li><strong>问答（QA）</strong>：<code>[SEP]</code> 作为问题和段落的分隔符，BERT 需要预测答案的起始和结束位置。</li><li><strong>命名实体识别（NER）</strong>：<code>[CLS]</code> 不是必须的，而是依赖 Token 级别的输出。</li></ul><blockquote class="book-hint warning"><p><strong>Note：</strong> <strong>对比 BERT 的 <code>[CLS]</code> 向量和平均池化获取句子表示的优缺点?</strong></p><ul><li><strong><code>[CLS]</code> 向量的优缺点</strong>：<ul><li><strong>简洁性</strong>：只需要一个向量（即 <code>[CLS]</code> 向量）来表示整个句子的语义，非常适用于分类任务，尤其是在输入句子较短时。</li><li><strong>端到端优化</strong>：由于 BERT 在预训练时优化了 <code>[CLS]</code> 向量，使其能够有效地聚合句子的语义信息，且通常与下游任务紧密相关。</li><li><strong>可能信息丢失</strong>：<code>[CLS]</code> 向量是通过加权和整个输入的 token 嵌入得到的，可能导致一些细节信息丢失，特别是当句子较长或复杂时。</li></ul></li><li><strong>平均池化（Mean Pooling）的优缺点</strong>：<ul><li><strong>信息保留</strong>：平均池化将所有 token 的表示进行平均，从而保留了句子中各个部分的信息，相比于 <code>[CLS]</code> 向量，它能保留更多的语义信息。</li><li><strong>缺乏上下文关注</strong>：平均池化忽略了 token 之间的复杂依赖关系，简单的加权平均可能无法捕捉到句子中不同部分的关联性，尤其是在多义词或句子结构复杂时。</li><li><strong>计算开销</strong>：对于长句子，平均池化需要计算所有 token 的平均值，可能增加计算开销，尤其在大规模数据集上。</li></ul></li></ul></blockquote></div></details><details><summary><strong class=custom-details-title>⁉️ BERT 微调的细节？</strong></summary><div class=markdown-inner><h2><b>BERT 微调的细节？</b></h2><p>BERT（Bidirectional Encoder Representations from Transformers）微调（Fine-tuning）通常是在预训练（Pre-training）后的基础上，将整个 BERT 模型与特定任务的分类头（Task-specific Head）一起训练，使其适应下游任务（Downstream Task）。</p><p>在微调过程中，输入文本经过分词（Tokenization）后，会被转换为对应的词嵌入（Token Embeddings）、位置嵌入（Position Embeddings）和分段嵌入（Segment Embeddings），然后输入 BERT 的 Transformer 层。模型通过多层双向自注意力（Bidirectional Self-Attention）计算上下文信息，并在最终的 <code>[CLS]</code>（分类标记）或其他适当的标记上添加任务特定的层，如全连接层（Fully Connected Layer）或 CRF（Conditional Random Field），然后使用任务相关的损失函数（Loss Function）进行优化，如交叉熵损失（Cross-Entropy Loss）用于分类任务。</p></div></details><details><summary><strong class=custom-details-title>⁉️ RoBERTa 的技术细节？它相比 BERT 做了哪些改进（如动态掩码、移除 NSP 任务）？</strong></summary><div class=markdown-inner><h2><b>RoBERTa 的技术细节？它相比 BERT 做了哪些改进（如动态掩码、移除 NSP 任务）？</b></h2><p><strong>RoBERTa（Robustly Optimized BERT Pretraining Approach）</strong> 在 BERT（Bidirectional Encoder Representations from Transformers）的基础上进行了多项优化，以提高模型的性能和泛化能力。</p><p>首先，RoBERTa 采用了 <strong>动态掩码（Dynamic Masking）</strong> 机制，即在每个训练 epoch 重新随机生成 Masked Language Model（MLM）掩码，而 BERT 仅在数据预处理阶段静态确定掩码。这种动态策略增加了模型学习的多样性，提高了其对不同掩码模式的适应能力。</p><blockquote class="book-hint warning"><p><strong>Note</strong>：<strong>训练时使用的动态掩码（Dynamic Masking）与静态掩码有何区别？</strong></p><p>BERT 原始论文使用的是 静态掩码，即在数据预处理阶段，对训练数据进行一次性 Mask 处理，并将其存储起来。在训练过程中，每次使用该数据时，<strong>Mask 位置都是固定的</strong>。</p><p>RoBERTa 在 BERT 的基础上采用了 动态掩码，即在每次数据加载时，都会 <strong>随机重新选择 Mask 位置</strong>，确保同一输入文本在不同训练轮次中 Mask 位置不同。这提高了数据多样性，使得模型能够学习更丰富的上下文表示，而不会过度拟合某些固定的 Mask 位置。</p></blockquote><p>其次，RoBERTa <strong>移除了 NSP（Next Sentence Prediction）任务</strong>，BERT 在训练时采用了 NSP 任务以增强模型对句子关系的理解，<strong>但研究发现 NSP 任务并未显著提升下游任务的表现，甚至可能影响模型的学习效率</strong>。因此，RoBERTa 采用了更大规模的 <strong>连续文本（Longer Sequences of Text） 进行预训练，而不再强制区分句子关系</strong>。最后，RoBERTa 通过 增加 batch size 和训练数据量，并 采用更长的训练时间，进一步优化了 BERT 预训练过程，使模型能够更充分地学习语言特征。</p></div></details><details><summary><strong class=custom-details-title>⁉️ DeBERTa 的“解耦注意力”机制（Disentangled Attention）如何分离内容和位置信息？</strong></summary><div class=markdown-inner><h2><b>DeBERTa 的“解耦注意力”机制（Disentangled Attention）如何分离内容和位置信息？</b></h2><p><strong>DeBERTa（Decoding-enhanced BERT with Disentangled Attention）</strong> 相较于 BERT 主要在 <strong>解耦注意力（Disentangled Attention）</strong> 和 <strong>相对位置编码（Relative Position Encoding）</strong> 方面进行了改进，以提升模型的语言理解能力。BERT 采用标准的 Transformer 注意力机制（Self-Attention），其中查询（Query）、键（Key）、值（Value）向量均是基于相同的嵌入（Embedding），这意味着 内容信息（Content Information） 和 位置信息（Positional Information） 混合在一起，限制了模型对句子结构的建模能力。而 DeBERTa 通过解耦注意力机制，<strong>对内容和位置信息分别编码，使得模型在计算注意力时能够更精确地理解不同词语之间的相对关系</strong>。</p><p>具体来说，DeBERTa 在计算注意力权重时，不是直接基于词向量（Token Embedding），而是 <strong>分别计算基于内容（Content-based Attention）和基于位置（Position-based Attention）的注意力得分，然后再将两者加权合并</strong>。这种方式使得 DeBERTa 能够在更长的依赖关系建模上表现更好。此外，DeBERTa 还采用了 <strong>增强的相对位置编码（Enhanced Relative Position Encoding）</strong>，相比 BERT 的绝对位置编码（Absolute Positional Encoding），能够更自然地处理长文本结构。</p></div></details><details><summary><strong class=custom-details-title>⁉️ ALBERT 如何通过参数共享降低模型参数量？</strong></summary><div class=markdown-inner><h2><b>ALBERT 如何通过参数共享降低模型参数量？</b></h2><p><strong>ALBERT（A Lite BERT）是对 BERT 模型的轻量化改进</strong>，旨在通过降低模型参数量而不显著影响模型性能。其主要技术细节涉及两项关键的优化策略：参数分解嵌入（Factorized Embedding） 和 跨层参数共享（Cross-Layer Parameter Sharing）。</p><ol><li><strong>参数分解嵌入（Factorized Embedding）</strong>：BERT 使用了一个巨大的词嵌入矩阵（embedding matrix），其大小通常是词汇表的大小与隐藏层维度（hidden size）的乘积。而 ALBERT 采用了参数分解方法，<strong>将词嵌入矩阵分解为两个低维矩阵</strong>，分别是一个较小的 词汇嵌入矩阵（Word Embedding Matrix） 和一个较小的 隐藏层嵌入矩阵（Hidden Layer Embedding Matrix）。具体来说，词嵌入矩阵被分解为两个矩阵，一个低维的嵌入矩阵和一个较小的输出矩阵，这样就显著减少了参数数量。例如，假设词嵌入矩阵的维度为 V x H（V 是词汇表大小，H 是隐藏层大小），通过分解成两个矩阵 V x E 和 E x H（E 为较小的维度），可以大幅度减少计算复杂度和存储需求。</li><li><strong>跨层参数共享（Cross-Layer Parameter Sharing）</strong>：在标准的 BERT 中，每一层 Transformer 都有一组独立的参数，而 ALBERT 通过跨层共享参数，减少了每一层的独立参数。具体来说，ALBERT 将模型中多个 Transformer 层 的参数进行共享，<strong>所有层都使用相同的权重</strong>。这样，尽管 ALBERT 保留了更多的层数（如 BERT 的 12 层改为 12 层的 ALBERT），但通过共享权重，整体的参数数量大幅度减少。参数共享的核心思想是：<strong>每一层 Transformer 的前向传播和反向传播使用相同的参数，从而减少了每层的权重数量，降低了内存消耗。</strong></li></ol></div></details><h3 id=t5bartseq2seq-预训练模型><strong>T5、BART（Seq2Seq 预训练模型）</strong>
<a class=anchor href=#t5bartseq2seq-%e9%a2%84%e8%ae%ad%e7%bb%83%e6%a8%a1%e5%9e%8b>#</a></h3><details><summary><strong class=custom-details-title>⁉️ T5 如何统一不同 NLP 任务的格式？其预训练任务（如 Span Corruption）具体如何实现？</strong></summary><div class=markdown-inner><h2><b>T5 如何统一不同 NLP 任务的格式？其预训练任务（如 Span Corruption）具体如何实现？</b></h2><p>T5（Text-to-Text Transfer Transformer）通过将所有 NLP 任务（如文本分类、机器翻译、问答、摘要生成等）<strong>统一转换为文本到文本（Text-to-Text）的格式</strong>，从而实现了一个通用的 NLP 框架。具体而言，无论是输入句子的分类任务还是填空任务，T5 都会将输入转换为文本序列，并要求模型生成相应的文本输出。例如，情感分析任务的输入可以是 <code>"sentiment: I love this movie"</code>，输出则是 <code>"positive"</code>，而机器翻译任务的输入可能是 <code>"translate English to French: How are you?"</code>，输出为 <code>"Comment ça va?"</code>。</p><blockquote class="book-hint warning"><p><strong>Note</strong>：Span Corruption（Span-Masked Language Modeling, SMLM）与 Masked Language Modeling（MLM）的核心区别在于 Mask 的方式和学习目标的不同。</p><ul><li><strong>MLM（Masked Language Modeling，BERT 采用）</strong>：<ul><li>MLM 主要是随机选择 <strong>单个 token 进行遮蔽</strong>，然后让模型预测被遮蔽的 token。例如：<pre tabindex=0><code>Input: &#34;I love [MASK] learning&#34;
Target: &#34;deep&#34; 
</code></pre></li><li>由于每次仅遮蔽少量 token，BERT 可能 <strong>无法学习到更长跨度的依赖关系</strong>，特别是对完整的子句或短语的理解较弱。</li></ul></li><li><strong>SMLM（Span-Masked Language Modeling，T5 采用）</strong>：<ul><li>SMLM 采用 Span Corruption，即 <strong>一次遮蔽连续的多个 token</strong>，并用特殊标记 <code>&lt;extra_id_0></code> 来表示被遮蔽部分。例如：<pre tabindex=0><code>Input: &#34;I &lt;extra_id_0&gt; deep &lt;extra_id_1&gt;.&#34;
Target: &#34;&lt;extra_id_0&gt; love &lt;extra_id_1&gt; learning&#34;
</code></pre></li><li>能够更好地 <strong>学习长距离的依赖关系</strong>，适用于生成式任务（如摘要、翻译）。训练难度更高。</li></ul></li></ul></blockquote><p>T5 采用的主要预训练任务是 <strong>Span Corruption（Span-Masked Language Modeling, SMLM）</strong>，这是一种变体的掩码语言建模（Masked Language Modeling, MLM）。具体来说，该任务会在输入文本中随机选择若干个 span（即连续的子序列），用特殊的 <code>&lt;extra_id_X></code> 令牌替换它们，并要求模型预测被遮蔽的内容。例如，原始文本 <code>"The quick brown fox jumps over the lazy dog"</code> 可能会被转换为 <code>"The &lt;extra_id_0> fox jumps over the &lt;extra_id_1> dog"</code>，而模型需要输出 <code>"quick brown"</code> <code>&lt;extra_id_0></code> 和 <code>“lazy”</code> <code>&lt;extra_id_1></code>。这种方式比 BERT 的单词级别掩码更灵活，有助于学习更丰富的上下文信息，从而提升生成任务的能力。</p><blockquote class="book-hint warning"><p><strong>Note</strong>：在 Span Corruption 预训练（Span Corruption Pretraining）中，被遮蔽的文本片段（Masked Span）的长度通常遵循 Zipf 分布（Zipf’s Law），<strong>即较短的片段更常见，而较长的片段较少，以模拟自然语言中的信息分布</strong>。具体而言，像 T5 这样的模型使用 <strong>几何分布（Geometric Distribution）</strong> 来采样 span 长度，以确保既有短范围的遮蔽，也有跨多个 token 的长范围遮蔽。</p><p>不同的遮蔽长度会影响模型的学习能力：较短的 span（例如 1-3 个 token）有助于模型学习局部语义填充能力（Local Context Understanding），而较长的 span（如 8-10 个 token 甚至更长）可以增强模型的全局推理能力（Global Reasoning）和段落级理解能力（Document-Level Comprehension）。如果 span 过短，模型可能更倾向于基于表面模式（Surface Patterns）预测，而非真正理解上下文；如果 span 过长，则可能导致学习任务过于困难，使得模型难以有效收敛。</p></blockquote></div></details><details><summary><strong class=custom-details-title>⁉️ 如何将预训练的 Encoder-Decoder 模型（如 T5）适配到具体下游任务？</strong></summary><div class=markdown-inner><h2><b>如何将预训练的 Encoder-Decoder 模型（如 T5）适配到具体下游任务？</b></h2><p>T5（Text-to-Text Transfer Transformer）模型与BERT相似，也需要通过在特定任务的数据上进行微调（fine-tuning）来完成下游任务。与BERT的微调有所不同，T5的主要特点包括：</p><ol><li><strong>任务描述（Task Prefix）</strong>：T5 的输入不仅包含原始文本，还需要附加一个任务描述。例如，在文本摘要（Text Summarization）任务中，输入可以是 &ldquo;summarize: 原文内容&rdquo;，而在问答（Question Answering）任务中，输入可以是 &ldquo;question: 问题内容 context: 相关文本&rdquo;。这种设计使 T5 能够以统一的 文本到文本（Text-to-Text） 形式处理不同任务。</li><li><strong>端到端序列生成（Sequence-to-Sequence Generation）</strong>：与 BERT 仅能进行分类或填空任务不同，T5 依赖其 Transformer 解码器（Transformer Decoder） 来生成完整的输出序列，使其适用于文本生成任务，如自动摘要、数据到文本转换（Data-to-Text Generation）等。</li><li><strong>无需额外层（No Task-Specific Layers）</strong>：在 BERT 微调时，通常需要在其顶层添加特定的任务头（Task-Specific Head），如分类层（Classification Layer）或 CRF（Conditional Random Field）层，而 T5 直接将任务作为输入提示（Prompt），并使用相同的模型结构进行训练，无需修改额外的网络层。</li></ol></div></details><details><summary><strong class=custom-details-title>⁉️ 什么是BART？BART 的预训练任务与 T5 有何异同？</strong></summary><div class=markdown-inner><h2><b>什么是BART？BART 的预训练任务（如 Text Infilling、Sentence Permutation）与 T5 的 Span Corruption 有何异同？</b></h2><p><strong>BART（Bidirectional and Auto-Regressive Transformers）</strong> 是一种结合了 BERT（Bidirectional Encoder Representations from Transformers）和 GPT（Generative Pretrained Transformer）优点的生成模型。BART 在预训练过程中采用了 <strong>自编码器（Autoencoder）</strong> 结构，其编码器部分像 BERT 一样使用双向编码，能够捕捉上下文信息，而解码器则是像 GPT 一样用于生成任务，通过自回归方式生成文本。</p><p>BART 的预训练任务包括 <strong>Text Infilling</strong> 和 <strong>Sentence Permutation</strong>：</p><ol><li><strong>Text Infilling</strong>：在这一任务中，模型需要从一段被掩盖部分的文本中恢复出被移除的词或词组。具体来说，给定一个输入文本，部分单词或短语被替换为掩码（mask），然后模型的任务是预测这些被掩盖的内容。这一任务类似于 BERT 的 Masked Language Model（MLM），但区别在于，BART 不仅仅是根据上下文来填充单一词汇，它的目标是生成整个缺失的文本片段。<pre tabindex=0><code>原始文本：“The quick brown fox jumps over the lazy dog in the park.”

掩盖后的文本：“The quick [MASK] jumps over the lazy dog in the park.”
</code></pre></li></ol><blockquote class="book-hint warning"><p><strong>Note</strong>：在 MLM 中，模型的目标是预测被随机掩盖的单个词（或子词）。虽然 Text Infilling 看起来类似于 MLM，但 BART 的 Text Infilling 中，<strong>掩盖的部分不仅限于单个词，而是可能是一个较大的片段或短语</strong>。通常，模型会随机选择一个较长的文本片段（如一个短语或句子的一部分）并用一个掩码标记替换，然后模型需要预测整个被掩盖的文本片段。</p><p><strong>总结，MLM遮一个词，Text Infilling 遮一个片段，Span Corruption 遮多个片段。</strong></p></blockquote><ol start=2><li><strong>Sentence Permutation</strong>：在这一任务中，输入文本的句子顺序被打乱，模型的任务是根据上下文恢复正确的句子顺序。这个任务是为了帮助模型学习长文本的结构和上下文关系，使其能够生成连贯且符合语法规则的文本。它与 T5 中的 Span Corruption 有一定的相似性，因为两者都涉及对文本进行扰动，并要求模型根据扰动后的文本恢复原始文本。<pre tabindex=0><code>原始文本：
“The dog chased the ball. It was a sunny day.”

打乱顺序后的文本：
“It was a sunny day. The dog chased the ball.”
</code></pre></li></ol></div></details><h3 id=gpt-2--gpt-3autoregressive-language-model><strong>GPT-2 / GPT-3（Autoregressive Language Model）</strong>
<a class=anchor href=#gpt-2--gpt-3autoregressive-language-model>#</a></h3><details><summary><strong class=custom-details-title>⁉️ Decoder-only 模型与 Encoder-Decoder 模型的核心区别是什么？</strong></summary><div class=markdown-inner><h2><b>Decoder-only 模型与 Encoder-Decoder 模型的核心区别是什么？</b></h2><p>Decoder-only（如GPT）仅保留解码器，通过自回归生成（逐词预测）完成任务。<strong>移除原始Transformer的编码器和交叉注意力层</strong>，保留掩码自注意力（Masked Self-Attention）与前馈网络（FFN）。输入处理时，文本序列添加特殊标记 <code>&lt;bos></code>（序列开始）和 <code>&lt;eos></code>（序列结束），目标序列为输入右移一位。适用任务主要为生成类任务（文本续写、对话、代码生成）。Encoder-Decoder（如原始Transformer、T5）分离编码器（理解输入）与解码器（生成输出），通过交叉注意力传递信息。适用任务主要为需严格分离输入理解与输出生成的任务（翻译、摘要、问答）。</p><p>Decoder-only模型通过 <strong>上下文学习（In-Context Learning）</strong> 将任务隐式编码到输入中（如添加“Translate English to French:”前缀），利用生成能力模拟翻译，完成和 Encoder-Decoder 一样的工作。但是 Encoder-Decoder在以下场景更具优势：</p><ol><li><strong>输入与输出解耦的复杂任务（如翻译）</strong>：Encoder-Decoder 模型的编码器可先提取完整语义，解码器再逐词生成，避免生成过程中的语义偏差，准确性更高。而Decoder-only模型（如GPT-3）需通过Prompt（如“Translate English to French: &mldr;”）隐式对齐输入输出，<strong>易受提示词设计影响</strong>。</li><li><strong>长文本处理效率</strong>：Encoder-Decoder：编码器一次性压缩输入为固定长度表示，解码生成时无需重复处理长输入（节省计算资源）。Decoder-only：<strong>生成每个词时需重新处理整个输入序列</strong>（如输入1000词的文档），导致计算复杂度高。</li></ol><ul><li><p><strong>总结来说</strong></p><ul><li><strong>Decoder-only</strong>：适合开放域生成任务，依赖生成连贯性与上下文学习，但对输入-输出结构复杂的任务效率较低。</li><li><strong>Encoder-Decoder</strong>：在需严格分离理解与生成、处理长输入、多任务统一的场景中更优，尤其适合翻译、摘要等结构化任务。</li><li>类比：Decoder-only像“自由创作的作家”，Encoder-Decoder像“严谨的翻译官”——前者更灵活，后者更精准。</li></ul></div></li></ul></details><details><summary><strong class=custom-details-title>⁉️ Decoder-only 模型的预训练任务通常是什么？</strong></summary><div class=markdown-inner><h2><b>Decoder-only 模型的预训练任务通常是什么？</b></h2><ol><li><strong>自回归语言建模（Autoregressive Language Modeling）</strong>：这个任务的目标是通过给定一部分文本（如前面的词或字符），预测接下来的单词或字符。例如，给定输入 <code>“The cat sat on the”</code>, 模型的任务是预测下一个单词是 <code>“mat”</code>。这个过程是自回归的，因为每次生成新的词都会基于模型已经生成的文本。自回归语言建模任务常见于 GPT（Generative Pre-trained Transformer） 等模型。</li><li><strong>文本填充任务（Cloze Task）</strong>：在这个任务中，模型的目标是根据上下文填充文本中的空白部分。例如，给定句子 <code>“The cat sat on the ____”</code>, 模型需要预测空白处应该填入的词 <code>“mat”</code>。这种填空任务常见于 BERT（Bidirectional Encoder Representations from Transformers） 的变体，如 Masked Language Modeling (MLM)。尽管 BERT 是基于 编码器（Encoder） 架构，但类似的目标也可以应用于 Decoder-only 架构，通过在训练时将部分词语随机遮蔽（mask）并让模型预测被遮蔽的部分。</li></ol></div></details><details><summary><strong class=custom-details-title>⁉️ 为什么 Decoder-only 模型通常采用自回归生成方式？因果掩码的作用及其实现方法。</strong></summary><div class=markdown-inner><h2><b>为什么 Decoder-only 模型通常采用自回归生成方式？因果掩码的作用及其实现方法。</b></h2><p>Decoder-only 模型通常采用自回归（Autoregressive）生成方式，因为这种方式能够通过模型已经生成的输出逐步生成下一个 token，从而形成连贯的序列。自回归生成方式使得每个步骤的生成依赖于前一步的生成结果，这种特性非常适合文本生成任务，如 <strong>语言建模（Language Modeling）</strong> 和 <strong>对话生成（Dialogue Generation）</strong>。通过这种方式，模型能够以逐词的方式生成文本，在每个步骤中利用之前的上下文信息预测下一个 token。即最大化序列联合概率，损失函数为交叉熵（Cross-Entropy）：</p><link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script><script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><span>\[
\begin{equation}
\mathcal{L} = -\sum_{t=1}^{T} \log P(w_t | w_{1:t-1 })
\end{equation}
\]</span><p>在 Decoder-only 模型中，<strong>因果掩码（Causal Mask）</strong> 的作用是确保模型在生成时 <strong>仅依赖于已生成的部分</strong>，而不会看到未来的信息。具体来说，在训练时，因果掩码会屏蔽未来 token 的信息，使得模型只能访问当前位置及其之前的 token，这样保证了每个时间步的预测仅受历史信息的影响，而无法窥视未来的输出。实现方法通常是在注意力机制（Attention Mechanism）中，通过对自注意力矩阵应用一个上三角矩阵的掩码，将未来的 token 阻止在计算中。例如，如果在生成第 4 个 token 时，模型不允许访问第 5、6 个 token，<strong>掩码就会在这些位置设置为负无穷</strong>，从而避免信息泄漏。</p></div></details><details><summary><strong class=custom-details-title>⁉️ 解释 Teacher Forcing 在 Decoder-only 模型训练中的作用及其潜在缺陷。</strong></summary><div class=markdown-inner><h2><b>解释 Teacher Forcing 在 Decoder-only 模型训练中的作用及其潜在缺陷。</b></h2><p>Teacher Forcing 是一种在训练序列生成模型时常用的技术，尤其是在 Decoder-only 模型（如 GPT 等自回归语言模型）的训练过程中。在 Teacher Forcing 中，模型在 <strong>每个时间步的输入不依赖于前一步的预测输出，而是直接使用真实的目标词（Ground Truth）作为输入</strong>。这意味着，在训练过程中，Decoder 在每个时间步都接收的是当前时间步的真实标签，而不是模型自己预测的输出。</p><p>这种方法的主要作用是加速模型训练，因为它 <strong>避免了模型在每次预测时犯错后导致的错误传播</strong>。在传统的训练过程中，模型每一次的预测都可能受到前一步错误的影响，这样会使得训练变得更加困难且收敛速度变慢。而 Teacher Forcing 确保每个时间步的输入都是正确的，从而减少了梯度计算中的误差积累，加速了训练过程。</p><p>然而，Teacher Forcing 也存在潜在缺陷，特别是在 推理阶段（Inference）。在训练阶段，模型总是看到真实的目标词作为输入，但在推理时，它必须依赖于自己之前的预测。Teacher Forcing 可能导致 <strong>模型在训练和推理时的分布不匹配（Exposure Bias）</strong>，即训练时的“理想环境”与实际推理时的“真实环境”不一致。若在训练中模型从未经历过自己预测错误的情况，它可能在推理时无法有效地纠正错误，从而影响生成的质量，导致 生成质量下降 或 无法适应真实环境中的错误传播。</p><p>为了缓解这个问题，一些方法如 <strong>Scheduled Sampling</strong> 被提出，它 <strong>逐渐减少训练时的 Teacher Forcing 比例</strong>，让模型在训练阶段逐步适应自己的预测输出，从而提高模型在推理时的稳定性和表现。</p></div></details><details><summary><strong class=custom-details-title>⁉️ 什么是 In-Context Learning？Decoder-only 模型如何实现零样本（Zero-Shot）推理能力？</strong></summary><div class=markdown-inner><h2><b>什么是 In-Context Learning？Decoder-only 模型如何实现零样本（Zero-Shot）推理能力？</b></h2><p><strong>上下文学习（In-Context Learning）</strong> 是指在推理过程中，<strong>模型通过理解并利用输入文本中的上下文信息来做出预测，而无需对任务进行额外的训练或微调（fine-tuning）</strong>。在这种方法中，模型通过直接接收任务的描述和示例输入-输出对，在推理时依赖这些信息来预测结果。与传统的基于训练的学习方式不同，上下文学习使得模型可以灵活应对新任务，而无需重新训练。</p><p>Decoder-only 模型（例如 GPT-3）通过将 <strong>任务的描述、示例以及相关输入文本提供给模型</strong>，使得模型能够在上下文中推理并生成响应。具体而言，GPT-3 和类似的 Transformer 模型基于自回归生成（autoregressive generation）机制，通过逐步生成下一个词，结合前文的上下文信息来进行推理。在这种机制下，模型无需显式的监督学习或微调，只要给定足够的上下文（例如任务描述和输入示例），它就能根据这些信息来做出预测。</p><blockquote class="book-hint warning"><ul><li><strong>Few-shot 示例</strong>：<pre tabindex=0><code>Q: Capital of France? A: Paris  
Q: Capital of Japan? A: Tokyo  
Q: Capital of Brazil? A:  
</code></pre><ul><li>模型通过前两例学习“Q-A”模式，生成“Brasília”。</li></ul></li><li><strong>Zero-shot 指令</strong>：<pre tabindex=0><code>Please answer the following question:  
What is the boiling point of water?  
Answer:  
</code></pre><ul><li>模型根据指令词“Please answer”生成“100°C (212°F) at sea level”。</li></ul></li></ul></blockquote><p>Zero-Shot 推理的实现方式在于 <strong>训练过程中接触了多种任务（如文本生成、问答、翻译、摘要等），使得模型能够在面对新任务时，依靠其通用语言理解能力完成推理，而无需重新训练或微调（Fine-tuning）</strong>。例如，假设我们要求模型完成一个数学问题，尽管模型未曾专门针对该任务训练，但它能依赖于其对语言的广泛理解，推断出合理的解答。大规模的训练数据为模型提供了更广泛的背景知识，使其能够在推理时利用丰富的上下文信息。</p><p>举个例子，当我们给出一个从未见过的任务，比如 “翻译以下文本成法语：‘I have a dream’”，GPT-3 可以准确地根据其训练数据中的语言模式生成翻译：“J’ai un rêve”。这是因为在其训练数据中，它已经接触过大量的文本翻译任务，并学会了如何根据提示进行推理。</p></div></details><details><summary><strong class=custom-details-title>⁉️ 对比 Greedy Search 与 Beam Search 在 Decoder-only 模型中的优缺点。</strong></summary><div class=markdown-inner><h2><b>对比 Greedy Search 与 Beam Search 在 Decoder-only 模型中的优缺点。</b></h2><p>Greedy Search 是一种简单的解码策略，它在 <strong>每个时间步（Time Step）选择概率最大的词作为输出</strong>。具体来说，对于每个生成步骤，模型会选择当前概率分布中 <strong>最大概率的词（Maximum Probability Word）</strong> 作为下一步的输出，并且该词会作为输入传递到下一个时间步。Greedy Search 的优点是 计算效率高（High Computational Efficiency），因为它只进行单一的选择和计算。然而，它的缺点是 <strong>局部最优问题（Local Optima）</strong>，即每次选择最有可能的词，而没有考虑未来可能的其他选择，因此它容易陷入次优解，导致生成的序列质量不高。</p><p>与此不同，Beam Search 是一种更加复杂的解码方法，它通过在每个时间步保留 <strong>多个候选序列（Multiple Candidate Sequences）</strong> 来进行搜索。具体来说，Beam Search 会在每个步骤保留 <strong>k个最优候选（Top-k Candidates）</strong>，而不是仅仅选择概率最大的一个词。通过这种方式，Beam Search 允许模型探索更多的可能性，从而提高生成质量。Beam Search 的优点是能够生成更具多样性的序列，通常能避免 Greedy Search 的局部最优问题，生成的结果更具 <strong>全局最优性（Global Optimality）</strong>。然而，它的缺点是 计算开销较大（Higher Computational Cost），因为需要维护多个候选序列，尤其在长文本生成时，这种计算开销可能会显著增加。</p></div></details><details><summary><strong class=custom-details-title>⁉️ Top-k 采样 和 Top-p（Nucleus）采样 的核心区别是什么？各适用于什么场景？</strong></summary><div class=markdown-inner><h2><b>Top-k 采样 和 Top-p（Nucleus）采样 的核心区别是什么？各适用于什么场景？</b></h2><p>Top-k 采样、Top-p 采样和 Greedy Search 和 Beam Search 一样都是解码策略（decoding strategies），它们的目标是生成高质量的文本。</p><p><strong>Top-k 采样</strong> 是一种基于概率分布的截断方法，在每次生成一个单词时，<strong>只从概率分布前 k 个最可能的词中选择一个进行生成，其他词的概率被截断为零</strong>。这种方法通过限制候选词的数量来控制生成文本的多样性，从而避免生成非常低概率的、不太合理的词汇。其公式可以表示为：</p><span>\[
P(w_i) = \begin{cases}
P(w_i), & \text{if } w_i \in \text{Top-}k \\
0, & \text{otherwise}
\end{cases}
\]</span><p>Top-k 表示从前 k 个概率最高的词中进行选择。Top-k 采样适用于生成任务中需要平衡多样性和合理性，如 <strong>对话生成（Dialogue Generation） 和 文本创作（Text Generation）</strong> 等场景。</p><p><strong>Top-p 采样（Nucleus Sampling）</strong> 则是一种基于 <strong>累积概率的采样方法</strong>。在每个时间步，Top-p 会选择一个最小的词集合，使得这些词的累积概率大于或等于 p。与 Top-k 采样固定候选词数不同，Top-p 采样动态调整候选词的数量，这使得它在生成过程中更加灵活和多样。其公式为：</p><span>\[
\sum_{i=1}^{n} P(w_i) \geq p
\]</span><p>P(w_i) 是每个候选词的概率，p 是预定的累积概率阈值。Top-p 采样适用于对生成多样性要求较高的任务，如 <strong>创意写作（Creative Writing） 或 开放域问答（Open-Domain QA）</strong>，它能够灵活调整候选词的数量，从而在生成中加入更多的随机性。</p></div></details><details><summary><strong class=custom-details-title>⁉️ 温度参数（Temperature）如何影响 Decoder-only 模型的生成结果？</strong></summary><div class=markdown-inner><h2><b>温度参数（Temperature）如何影响 Decoder-only 模型的生成结果？</b></h2><p>温度参数（Temperature）在 Decoder-only 模型（如 GPT）中用于 <strong>控制生成文本的随机性或确定性</strong>。它的作用是在模型生成过程中对 <strong>输出概率分布（Output Probability Distribution）进行调整</strong>，从而影响模型的生成结果。温度的公式通常为：</p><span>\[
P(w) = \frac{e^{\frac{log(P(w))}{T}}}{\sum_{w{\prime}} e^{\frac{log(P(w{\prime}))}{T}}}
\]</span><p>其中，P(w) 是生成某个单词 w 的原始概率，T 是温度参数， w&rsquo; 是所有可能的单词。温度参数 T 控制了概率分布的平滑度。当 T = 1 时，模型按照正常的概率分布生成输出；<strong>当 T > 1 时，概率分布变得更加平缓，生成的结果会更加随机</strong>，可能导致较为多样化的输出；<strong>当 T &lt; 1 时，概率分布变得更加陡峭，模型会更加倾向于选择概率较高的词语</strong>，从而生成更加确定性和保守的结果。</p><p><strong>温度的调整作用于 softmax 函数（用于将模型的原始输出转换为概率分布）</strong>。通过改变温度值，模型可以控制生成内容的多样性和创造性。较高的温度通常会增加生成内容的创新性，但可能导致语法错误或不连贯的输出，而较低的温度则会使输出更加连贯和符合预期，但可能缺乏创意或多样性。</p><p>例如，在文本生成任务中，若我们将温度设为 1.0，则生成的文本遵循模型原本的概率分布；若我们将温度设为 0.5，生成的文本将更加趋向于模型最有可能生成的词，文本可能会变得单调和缺乏创意；若温度设为 1.5，则生成的文本可能会表现出更多的创造性，但也可能出现语法错误或不太连贯的部分。</p></div></details><details><summary><strong class=custom-details-title>⁉️ 为什么 Decoder-only 模型推理时需要 KV Cache？如何优化其内存占用？</strong></summary><div class=markdown-inner><h2><b>为什么 Decoder-only 模型推理时需要 KV Cache？如何优化其内存占用？</b></h2><blockquote class="book-hint warning"><p><strong>Note</strong>：在推理阶段，所有的 <strong>权重（Weights）已经通过训练学习完毕（不再改变）</strong>。输入的句子会按照预定义的规则转换成 Query (Q)、Key (K) 和 Value (V) 向量。无论是训练阶段还是推理阶段，句子中的 <strong>每个 token（词）都会有一个唯一对应的 Key 和 Value 向量</strong>。在自回归生成过程中，每次输入新的时间步 x_t ，<strong>会计算出当前时刻的 Query 向量 Q_t ，同时，新的 Key 和 Value 向量 K_t, V_t 会与之前的 KV 缓存合并</strong>，形成当前时刻的完整历史信息。新的 Query 用于查询当前输入和历史信息之间的关系，从而生成有意义的上下文信息，用于生成下一个 token。</p></blockquote><p>在 Decoder-only 模型（如 GPT）中，推理时需要 KV Cache（Key-Value Cache）来提高计算效率和减少内存占用。KV Cache 主要用于存储模型在每个时间步生成的 Key 和 Value 向量，这些向量用于自注意力机制（Self-Attention）中计算当前词与之前所有词之间的依赖关系。具体来说，<strong>当模型生成一个新的 token 时，它不仅要计算当前 token 的自注意力，还需要利用已经生成的 tokens 的表示来计算新的 token</strong>，因此必须保存这些 Key 和 Value 向量。</p><blockquote class="book-hint warning"><p><strong>Note</strong>：假设我们正在进行推理，模型已经生成了序列 “I love deep learning” 中的前四个词 “I love deep learning”（也就是说，当前时间步是第5个词）。在传统推理中，如果没有 KV Cache，模型在计算每个新的 token 时都需要重新计算与之前所有已经生成的 tokens（“I love deep learning”）之间的依赖关系。</p><ul><li>对于第5个词 “model”，模型首先计算 “model” 和 “I”、“love”、“deep”、“learning” 之间的自注意力（self-attention）。为了计算这个自注意力，模型需要 <strong>重新计算每个之前词的 Key 和 Value 向量</strong>。</li></ul><p>为了避免这种重复计算，使用 KV Cache 的方法是：当我们生成第5个词时，模型会保存 <strong>前四个词（“I love deep learning”）的 Key 和 Value 向量</strong>。下一次生成新 token 时（比如第6个词），模型只需要利用 缓存中的 Key 和 Value 向量 来计算当前 token 和已经生成的历史 tokens 之间的依赖关系，而无需重新计算历史 tokens 的表示。</p><ul><li>对于第5个词 “model”，模型首先计算 “model” 和缓存中的 “I love deep learning” 之间的自注意力。</li><li>在此过程中，模型使用的是 <strong>已经缓存的 Key 和 Value 向量，而不是重新计算整个输入序列的 Key 和 Value 向量</strong>。</li><li>当模型生成第6个词时，只需将第5个词 “model” 的 Key 和 Value 向量加入缓存，并计算与缓存中所有其他 tokens 之间的关系。</li></ul></blockquote><p>在传统的推理过程中，模型需要重新计算每个时间步的所有 Key 和 Value 向量，导致计算量和内存占用急剧增加。使用 KV Cache 后，模型只需要保存每一层的 Key 和 Value 向量，从而避免了重复计算，极大地提升了推理效率。</p><p><strong>如何优化内存占用：</strong></p><ol><li><strong>动态 KV 缓存大小</strong>：在一些任务中，并不需要保留所有时间步的 Key 和 Value 向量。例如，对于生成式任务，缓存可以按照一定步长进行清理，或者只保留 前 n 步 的缓存。</li><li><strong>分层缓存</strong>：根据模型层数和层间依赖，可以在 不同层 采用不同的缓存策略。例如，可以对较低层进行更频繁的缓存清理，对较高层保留更多的缓存信息。</li><li><strong>量化（Quantization）</strong>：通过降低 Key 和 Value 向量的精度（例如从浮点数精度到低精度存储），减少内存占用，同时尽量保持推理的精度。</li></ol></div></details><details><summary><strong class=custom-details-title>⁉️ Decoder-only 模型如何处理长文本依赖问题？（如稀疏注意力、窗口注意力）</strong></summary><div class=markdown-inner><h2><b>Decoder-only 模型如何处理长文本依赖问题？（如稀疏注意力、窗口注意力）</b></h2><p>Decoder-only 模型（如 GPT 类模型）通过不同的技术来处理长文本中的依赖问题，尤其是在处理长序列时，传统的 全局注意力（Global Attention） 计算会变得非常消耗资源。为了解决这个问题，Decoder-only 模型采用了 稀疏注意力（Sparse Attention） 和 窗口注意力（Windowed Attention） 等方法，从而有效地减小计算复杂度并增强长文本的建模能力。</p><p><strong>稀疏注意力（Sparse Attention）</strong> 的 <strong>核心思想是通过引入局部化注意力机制，使得每个 token 只与部分上下文进行交互，从而减少计算量</strong>。具体而言，稀疏注意力只计算一部分的注意力权重而不是全部，这样可以降低模型计算的复杂度。常见的稀疏注意力结构包括 固定模式（Fixed Patterns） 和 学习模式（Learned Patterns），其中一个代表固定的局部上下文窗口，另一个则依赖于模型在训练过程中自适应学习关注哪些位置的关系。稀疏注意力通常通过 Top-k 注意力（Top-k Attention） 或 Block-sparse 格式 来实现。</p><p><strong>窗口注意力（Windowed Attention）</strong> 是一种将输入序列划分为多个固定大小的窗口（或块），每个窗口内的 token 之间通过注意力进行交互，而窗口之间没有直接的依赖关系。窗口大小是一个超参数，通常会选择较小的窗口以限制每次计算的注意力范围，从而减少计算负担。通过这种方式，模型能够在较低的计算成本下捕捉到长序列中的重要信息，同时避免了全局注意力带来的高昂计算开销。</p></div></details><hr><h2 id=预训练细节><strong>预训练细节</strong>
<a class=anchor href=#%e9%a2%84%e8%ae%ad%e7%bb%83%e7%bb%86%e8%8a%82>#</a></h2><hr><h3 id=预训练定义><strong>预训练定义</strong>
<a class=anchor href=#%e9%a2%84%e8%ae%ad%e7%bb%83%e5%ae%9a%e4%b9%89>#</a></h3><details open><summary><strong class=custom-details-title>⁉️ 什么是预训练？与传统监督学习的区别？</strong></summary><div class=markdown-inner><h2><b>什么是预训练？与传统监督学习的区别？</b></h2><p>预训练（Pretraining）是一种在大规模无标注数据（Unlabeled Data）上训练深度学习模型的技术，特别常用于自然语言处理（NLP）中的大规模语言模型。在预训练阶段，模型通常采用 <strong>自监督学习（Self-Supervised Learning）方法</strong>，通过预测被遮蔽的词（如 BERT 的掩码语言模型 Masked Language Model, MLM）或基于上下文预测下一个词（如 GPT 的自回归语言模型 Autoregressive Language Model, AR）来学习文本的统计特性和语义表示（Semantic Representation）。</p><p>相比传统的监督学习（Supervised Learning），预训练 <strong>不需要大量人工标注数据，而是利用大规模无标签语料</strong>，使模型具备广泛的语言理解能力。随后，模型可以通过 <strong>微调（Fine-Tuning）在小规模标注数据上进一步优化</strong>，以适应具体任务。这种方式相比传统监督学习更加高效，尤其适用于数据标注成本高的任务，同时提升模型的泛化能力（Generalization Ability）和适应性（Adaptability）。</p><blockquote class="book-hint warning"><p><strong>Note</strong>：Pre-training 是在大规模无监督数据上训练模型，而 Fine-tuning 是在特定任务或数据集上对模型进行微调。</p></blockquote></div></details><hr><h3 id=预训练数据><strong>预训练数据</strong>
<a class=anchor href=#%e9%a2%84%e8%ae%ad%e7%bb%83%e6%95%b0%e6%8d%ae>#</a></h3><h4 id=数据来源><strong>数据来源</strong>
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e6%9d%a5%e6%ba%90>#</a></h4><p>大型语言模型的训练依赖于 <strong>多种数据来源（Data Sources）</strong>，其中常见的数据集包括 Common Crawl（一个大规模的互联网网页爬取数据集）、书籍（Books）、学术论文（Academic Papers，如 arXiv 和 PubMed）、以及开源代码（Open-Source Code，如 The Stack）。</p><p>不同的 LLM 在训练时采用的数据占比各不相同，例如 GPT-3 的训练数据主要包括 60% 的 Common Crawl、16% 的书籍、22% 的 WebText 以及 3% 的维基百科（Wikipedia），而 LLaMA 采用的数据更注重高质量文本，如 67% 来自 Common Crawl（但经过严格过滤），15% 来自 C4 数据集（Colossal Clean Crawled Corpus），4.5% 是 arXiv 论文，4.5% 是 GitHub 代码，以及 4% 的 Wikipedia。这种数据分布的差异直接影响了模型的知识覆盖范围、代码理解能力以及推理能力（Reasoning Ability）。例如，LLaMA 在训练过程中更加强调高质量文本，以减少噪声数据对模型的干扰，而 GPT-3 则采用了更广泛的数据覆盖，以增强通用性。</p><hr><h4 id=数据清洗><strong>数据清洗</strong>
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e6%b8%85%e6%b4%97>#</a></h4><p>数据清洗（Data Cleaning）旨在提高训练数据的质量并减少噪声对模型的负面影响。数据清洗的核心步骤包括 <strong>去重（Deduplication）</strong>，即移除重复文本，以防止模型对某些模式过度拟合；<strong>去噪（Denoising）</strong>，即去除格式错误、乱码或其他无意义的内容；以及 <strong>过滤低质量或有害内容（Filtering Low-Quality/Harmful Content）</strong>，确保训练数据符合道德和安全标准。</p><p>实现这些步骤的常见方法包括启发式规则（Heuristic Rules），如 <strong>基于正则表达式或关键词的过滤</strong>，以及分类器（Classifiers），例如 OpenAI 在 GPT-3 训练过程中使用的 <strong>质量过滤器（Quality Filter）</strong>，它基于监督学习模型来识别并去除低质量数据。有效的数据清洗能够显著提升模型的泛化能力和输出质量，使其在下游任务中表现更为可靠。</p><hr><h4 id=数据配比与顺序><strong>数据配比与顺序</strong>
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e9%85%8d%e6%af%94%e4%b8%8e%e9%a1%ba%e5%ba%8f>#</a></h4><p>数据配比（Data Ratio）与顺序（Data Ordering）对于模型的收敛速度和最终性能至关重要。混合数据集的采样策略（Sampling Strategy for Mixed Datasets）通常 <strong>依据领域（Domain）或语言（Language）进行加权</strong>，以确保模型能够充分学习关键领域知识或多语言特性。例如，在多语言训练中，可以 <strong>根据不同语言的资源量和下游任务需求进行采样加权（Weighted Sampling）</strong>，避免低资源语言在训练过程中被高资源语言所淹没。</p><p>此外，数据的顺序也会对模型学习产生显著影响，受“课程学习”（Curriculum Learning）思想的启发，<strong>训练数据可以按照从简单到复杂的顺序进行排列，以帮助模型更稳定地学习，例如先训练高质量、语法清晰的数据，再逐步引入更复杂或嘈杂的数据</strong>。这种方法能够有效改善模型的收敛性，提高最终的泛化能力。</p><hr><h3 id=预训练流程><strong>预训练流程</strong>
<a class=anchor href=#%e9%a2%84%e8%ae%ad%e7%bb%83%e6%b5%81%e7%a8%8b>#</a></h3><details open><summary><strong class=custom-details-title>⁉️ LLM 的预训练流程通常涉及到哪些环节？</strong></summary><div class=markdown-inner><h2><b>LLM 的预训练流程通常涉及到哪些环节？</b></h2><p>LLM的预训练流程通常包括多个关键环节，首先是 <strong>数据构建</strong>。通过爬取来自多源的文本数据（如网页、书籍、代码等），并进行严格的清洗（去重、去噪、质量过滤），然后根据不同领域或语言进行动态采样以优化数据的配比。这些数据随后用于 <strong>训练一个Tokenizer（分词器）</strong>，常用的算法包括BPE（Byte Pair Encoding）和WordPiece，它们生成适合任务的词汇表。</p><p>接下来，<strong>选择合适的模型架构和参数规模</strong> 是至关重要的。常见的架构包括Decoder-only的GPT类模型和Encoder-Decoder的T5类模型，具体选择依据任务需求而定。同时，模型的参数规模也需根据Chinchilla定律来平衡数据量、模型大小和计算资源，以便提高训练效率。为了应对海量数据的训练，通常 <strong>采用分布式训练框架（如DeepSpeed与Megatron-LM），并启用混合精度训练</strong>（如FP16或BF16），结合梯度缩放来加速计算过程。</p><p>在训练过程中，必须通过 <strong>监控损失曲线、计算资源的利用率等指标</strong>，确保训练稳定性和高效性。此外，<strong>定期保存Checkpoint（模型检查点）</strong> 以防止训练过程中断时丢失重要进展。训练的目标通常是基于MLM（Masked Language Modeling，掩码预测）或CLM（Causal Language Modeling，自回归生成）进行无监督学习，具体选择取决于模型设计和任务目标。</p><p>完成训练后，需要 <strong>通过困惑度（PPL，Perplexity）和领域Benchmark（如MMLU）等标准进行模型性能评估</strong>，并进行大规模的长文本生成测试（“大海捞针”测试）来考察模型的泛化能力。如果模型表现出良好的通用能力，接下来可以针对特定领域或长上下文需求进行进一步的预训练，以增强模型的专项性能。</p></div></details><details open><summary><strong class=custom-details-title>⁉️ Tokenizer 在实际模型预训练阶段是如何被使用的？词表大小对模型性能的影响？</strong></summary><div class=markdown-inner><h2><b>Tokenizer 在实际模型预训练阶段是如何被使用的？词表大小对模型性能的影响？</b></h2><p>Tokenizer（分词器）的主要作用是 <strong>将原始文本转换为模型可理解的离散数值表示</strong>，即Token ID（标记序列）。这个过程通常包括分词（Tokenization）、映射（Mapping to Vocabulary） 和 填充/截断（Padding/Truncation）。在分词时，不同的 Tokenizer会根据预定义的 <strong>词表（Vocabulary）</strong> 将文本拆分成最优的子词单元。</p><p><strong>词表的大小决定了模型可识别的唯一 Token 数量</strong>，比如 LLaMA 采用了 32k 的词表，而 GPT-2 使用了 50k 词表。较大的词表允许模型以更少的 Token 表示相同文本，<strong>提高表达能力，但也增加了参数规模和计算复杂度</strong>；而较小的词表则 <strong>减少了计算需求，但可能导致序列变长，进而影响训练效率</strong>。因此，在预训练阶段，词表大小的选择会直接影响模型的记忆能力、计算成本以及推理速度。</p><blockquote class="book-hint warning"><p><strong>Note</strong>：词表（Vocabulary）既可以直接使用预训练模型提供的标准词表，也可以根据自己的数据集重新训练一个词表，具体取决于应用需求：</p><ol><li><strong>直接使用预训练词表</strong>：如 GPT-3、LLaMA、T5 等开源模型的 Tokenizer 已经基于大规模文本语料（如 Common Crawl、Wikipedia）训练了词表，并随模型一起发布。直接使用这些词表能够确保与原始模型的 Token 方式一致，避免 Token 不匹配导致的性能下降。这种方法 <strong>适用于大多数 NLP 任务</strong>，特别是在迁移学习（Transfer Learning）场景下。</li><li><strong>基于自有数据训练新词表</strong>：如果 <strong>目标领域与通用 NLP 语料差异较大（如医学、法律、金融等专业领域），或者需要支持特定语言（如低资源语言或多语言任务）</strong>，可以使用 SentencePiece（支持 BPE、Unigram）或 Hugging Face Tokenizers 来从头训练词表。训练时通常会调整 词表大小（Vocabulary Size），使其适配目标任务。较大的词表可以减少 OOV（Out-Of-Vocabulary）问题，而较小的词表能减少计算复杂度，提高推理速度。</li></ol></blockquote></div></details><details open><summary><strong class=custom-details-title>⁉️ 什么是参数初始化？有哪些适合 LLM 训练的参数初始化策略（Parameter Initialization）？</strong></summary><div class=markdown-inner><h2><b>什么是参数初始化？有哪些适合 LLM 训练的参数初始化策略（Parameter Initialization）？</b></h2><p>参数初始化（Parameter Initialization） 是神经网络训练中的一个关键步骤，旨在为 <strong>网络的权重（weights）和偏置（biases）赋予初始值</strong>。这些初始值对模型的训练收敛速度、稳定性及最终性能有着重要影响。<strong>合理的参数初始化策略能够避免梯度消失（Vanishing Gradient）或梯度爆炸（Exploding Gradient）等问题，进而提高训练效率</strong>。</p><p>对于 大规模语言模型（Large Language Models, LLM） 的训练，一些常见且适用的参数初始化策略包括：</p><ol><li><strong>Xavier 初始化（Xavier Initialization）</strong>：也叫做 Glorot 初始化，它通过考虑输入和输出的神经元数量来设置权重的方差。具体来说，权重的方差设置为：</li></ol><span>\[
W_{i,j} \sim N\left(0, \frac{2}{n_{\text{in}} + n_{\text{out}}}\right)
\]</span><p>其中 n_in 和 n_out 分别是当前层的输入和输出神经元数量。此策略通常用于 sigmoid 或 tanh 激活函数的网络，能够帮助缓解梯度消失问题。</p><blockquote class="book-hint warning"><p><strong>Note</strong>：<strong>Xavier 初始化适用于激活函数是 sigmoid 或 tanh 的网络</strong>的原因是这些激活函数的<strong>导数容易趋于零</strong>，尤其是在输入值落入激活函数的<strong>饱和区（Sigmoid 的两侧平坦区域）</strong>。如果权重初始化过大，输入会快速进入饱和区，导致梯度消失。如果权重初始化过小，输出信号会逐层衰减，最终导致梯度消失。</p><p>Xavier 的初始化方法<strong>将权重分布限定在一个较小的范围内</strong>，使输入值主要分布在 Sigmoid 和 Tanh 的线性区，避免梯度消失。在较深的网络中，信号可能仍会因为层数的累积效应导致衰减或放大。</p></blockquote><ol start=2><li><strong>He 初始化（He Initialization）</strong>：类似于 Xavier 初始化，但特别适用于 ReLU 激活函数。它通过设置权重的方差，有效地解决了 ReLU 激活函数中常见的 dying ReLU 问题，即一些神经元始终不激活。</li></ol><span>\[
W_{i,j} \sim N\left(0, \frac{2}{n_{\text{in}}}\right)
\]</span><blockquote class="book-hint warning"><p><strong>Note</strong>：<strong>He 初始化适用于激活函数是ReLU及其变种</strong>的原因是对于 ReLU，当输入为负时，输出恒为 0；当输入为正时，输出为原值。由于一部分神经元输出会被截断为 0，导致<strong>有效的参与计算的神经元数量减少</strong>（称为“稀疏激活”现象）。如果初始化权重过小，信号会迅速减弱，导致梯度消失；而如果权重过大，信号会迅速放大，导致梯度爆炸。</p><p>He 初始化通过<strong>设定较大的方差</strong>，补偿了 ReLU 截断负值导致的信号损失。这样可以让激活值的分布更均衡，<strong>避免信号快速衰减或放大</strong>。He 初始化<strong>根据输入层大小调整权重的方差，使每层的输出方差保持相对稳定</strong>，即使网络层数增加，信号也不会显著衰减或爆炸。</p></blockquote><ol start=3><li><strong>Pretrained Initialization</strong>：对于 LLM，使用在大规模数据集上预训练的权重作为初始化参数（例如 BERT、GPT）是一种常见且有效的做法。通过 <strong>迁移学习（Transfer Learning）</strong>，这种初始化策略能够显著加速训练过程，并提升模型的性能。</li></ol></div></details></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#encoder-onlybert><strong>Encoder-Only（BERT）</strong></a><ul><li><a href=#bert-的预训练与微调机制><strong>BERT 的预训练与微调机制</strong></a></li></ul></li><li><a href=#encoder-decodert5><strong>Encoder-Decoder（T5）</strong></a><ul><li><a href=#t5-的预训练与微调机制><strong>T5 的预训练与微调机制</strong></a></li></ul></li><li><a href=#decoder-onlygpt><strong>Decoder-Only（GPT）</strong></a><ul><li><a href=#gpt如何区分不同任务如问答-vs-文本生成><strong>GPT如何区分不同任务（如问答 vs 文本生成）？</strong></a></li></ul></li><li><a href=#基础预训练模型><strong>基础预训练模型</strong></a><ul><li><a href=#bertmasked-language-model-next-sentence-prediction><strong>BERT（Masked Language Model, Next Sentence Prediction）</strong></a></li><li><a href=#t5bartseq2seq-预训练模型><strong>T5、BART（Seq2Seq 预训练模型）</strong></a></li><li><a href=#gpt-2--gpt-3autoregressive-language-model><strong>GPT-2 / GPT-3（Autoregressive Language Model）</strong></a></li></ul></li><li><a href=#预训练细节><strong>预训练细节</strong></a><ul><li><a href=#预训练定义><strong>预训练定义</strong></a></li><li><a href=#预训练数据><strong>预训练数据</strong></a></li><li><a href=#预训练流程><strong>预训练流程</strong></a></li></ul></li></ul></nav></div></aside></main></body></html>